{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GitOps Toolkit \u00b6 The GitOps Toolkit is a set of composable APIs and specialized tools that can be used to build a Continuous Delivery platform on top of Kubernetes. These tools are built with Kubernetes controller-runtime libraries and they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools. The GitOps Toolkit components interact with each other via Kubernetes events and are responsible for the reconciliation of their designated API objects. Work in Progress We envision a future where Flux v2 and Helm Operator v2 will be assembled from the GitOps Toolkit components. The Flux CD team is looking for feedback and help as the toolkit is in an active experimentation phase. If you wish to take part in this quest please reach out to us on Slack and GitHub. Target features: Source management Kustomize and Helm support Event-based and on-a-schedule reconciliation Role-based reconciliation (multi-tenancy) Health assessment (clusters and workloads) Dependency management (infra and workloads) Alerting to external systems (webhook senders) External events handling (webhook receivers) Source write-back (automated patching) Policy driven validation (OPA, admission controllers) Seamless integration with Git providers (GitHub, GitLab, Bitbucket) Interoperability with workflow providers (GitHub Actions, Tekton, Argo) Interoperability with CAPI providers Components: Toolkit CLI Source Controller GitRepository CRD HelmRepository CRD HelmChart CRD Kustomize Controller Kustomization CRD Helm Controller HelmRelease CRD Notification Controller Provider CRD Alert CRD Receiver CRD To get started with the toolkit please follow this guide .","title":"Introduction"},{"location":"#gitops-toolkit","text":"The GitOps Toolkit is a set of composable APIs and specialized tools that can be used to build a Continuous Delivery platform on top of Kubernetes. These tools are built with Kubernetes controller-runtime libraries and they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools. The GitOps Toolkit components interact with each other via Kubernetes events and are responsible for the reconciliation of their designated API objects. Work in Progress We envision a future where Flux v2 and Helm Operator v2 will be assembled from the GitOps Toolkit components. The Flux CD team is looking for feedback and help as the toolkit is in an active experimentation phase. If you wish to take part in this quest please reach out to us on Slack and GitHub. Target features: Source management Kustomize and Helm support Event-based and on-a-schedule reconciliation Role-based reconciliation (multi-tenancy) Health assessment (clusters and workloads) Dependency management (infra and workloads) Alerting to external systems (webhook senders) External events handling (webhook receivers) Source write-back (automated patching) Policy driven validation (OPA, admission controllers) Seamless integration with Git providers (GitHub, GitLab, Bitbucket) Interoperability with workflow providers (GitHub Actions, Tekton, Argo) Interoperability with CAPI providers Components: Toolkit CLI Source Controller GitRepository CRD HelmRepository CRD HelmChart CRD Kustomize Controller Kustomization CRD Helm Controller HelmRelease CRD Notification Controller Provider CRD Alert CRD Receiver CRD To get started with the toolkit please follow this guide .","title":"GitOps Toolkit"},{"location":"cmd/tk/","text":"tk \u00b6 Command line utility for assembling Kubernetes CD pipelines Synopsis \u00b6 Command line utility for assembling Kubernetes CD pipelines the GitOps way. Examples \u00b6 # Check prerequisites tk check --pre # Install the latest version of the toolkit tk install --version=master # Create a source from a public Git repository tk create source git webapp-latest \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master \\ --interval=3m # List GitRepository sources and their status tk get sources git # Trigger a GitRepository source reconciliation tk reconcile source git gitops-system # Export GitRepository sources in YAML format tk export source git --all > sources.yaml # Create a Kustomization for deploying a series of microservices tk create kustomization webapp-dev \\ --source=webapp-latest \\ --path=\"./deploy/webapp/\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --health-check=\"Deployment/backend.webapp\" \\ --health-check=\"Deployment/frontend.webapp\" \\ --health-check-timeout=2m # Trigger a git sync of the Kustomization's source and apply changes tk reconcile kustomization webapp-dev --with-source # Suspend a Kustomization reconciliation tk suspend kustomization webapp-dev # Export Kustomizations in YAML format tk export kustomization --all > kustomizations.yaml # Resume a Kustomization reconciliation tk resume kustomization webapp-dev # Delete a Kustomization tk delete kustomization webapp-dev # Delete a GitRepository source tk delete source git webapp-latest # Uninstall the toolkit and delete CRDs tk uninstall --crds Options \u00b6 -h, --help help for tk --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk bootstrap - Bootstrap toolkit components tk check - Check requirements and installation tk completion - Generates bash completion scripts tk create - Create or update sources and resources tk delete - Delete sources and resources tk export - Export resources in YAML format tk get - Get sources and resources tk install - Install the toolkit components tk reconcile - Reconcile sources and resources tk resume - Resume suspended resources tk suspend - Suspend resources tk uninstall - Uninstall the toolkit components","title":"Overview"},{"location":"cmd/tk/#tk","text":"Command line utility for assembling Kubernetes CD pipelines","title":"tk"},{"location":"cmd/tk/#synopsis","text":"Command line utility for assembling Kubernetes CD pipelines the GitOps way.","title":"Synopsis"},{"location":"cmd/tk/#examples","text":"# Check prerequisites tk check --pre # Install the latest version of the toolkit tk install --version=master # Create a source from a public Git repository tk create source git webapp-latest \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master \\ --interval=3m # List GitRepository sources and their status tk get sources git # Trigger a GitRepository source reconciliation tk reconcile source git gitops-system # Export GitRepository sources in YAML format tk export source git --all > sources.yaml # Create a Kustomization for deploying a series of microservices tk create kustomization webapp-dev \\ --source=webapp-latest \\ --path=\"./deploy/webapp/\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --health-check=\"Deployment/backend.webapp\" \\ --health-check=\"Deployment/frontend.webapp\" \\ --health-check-timeout=2m # Trigger a git sync of the Kustomization's source and apply changes tk reconcile kustomization webapp-dev --with-source # Suspend a Kustomization reconciliation tk suspend kustomization webapp-dev # Export Kustomizations in YAML format tk export kustomization --all > kustomizations.yaml # Resume a Kustomization reconciliation tk resume kustomization webapp-dev # Delete a Kustomization tk delete kustomization webapp-dev # Delete a GitRepository source tk delete source git webapp-latest # Uninstall the toolkit and delete CRDs tk uninstall --crds","title":"Examples"},{"location":"cmd/tk/#options","text":"-h, --help help for tk --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options"},{"location":"cmd/tk/#see-also","text":"tk bootstrap - Bootstrap toolkit components tk check - Check requirements and installation tk completion - Generates bash completion scripts tk create - Create or update sources and resources tk delete - Delete sources and resources tk export - Export resources in YAML format tk get - Get sources and resources tk install - Install the toolkit components tk reconcile - Reconcile sources and resources tk resume - Resume suspended resources tk suspend - Suspend resources tk uninstall - Uninstall the toolkit components","title":"SEE ALSO"},{"location":"cmd/tk_bootstrap/","text":"tk bootstrap \u00b6 Bootstrap toolkit components Synopsis \u00b6 The bootstrap sub-commands bootstrap the toolkit components on the targeted Git provider. Options \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for bootstrap --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") -v, --version string toolkit version (default \"latest\") Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk bootstrap github - Bootstrap toolkit components in a GitHub repository tk bootstrap gitlab - Bootstrap toolkit components in a GitLab repository","title":"Bootstrap"},{"location":"cmd/tk_bootstrap/#tk-bootstrap","text":"Bootstrap toolkit components","title":"tk bootstrap"},{"location":"cmd/tk_bootstrap/#synopsis","text":"The bootstrap sub-commands bootstrap the toolkit components on the targeted Git provider.","title":"Synopsis"},{"location":"cmd/tk_bootstrap/#options","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for bootstrap --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") -v, --version string toolkit version (default \"latest\")","title":"Options"},{"location":"cmd/tk_bootstrap/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_bootstrap/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk bootstrap github - Bootstrap toolkit components in a GitHub repository tk bootstrap gitlab - Bootstrap toolkit components in a GitLab repository","title":"SEE ALSO"},{"location":"cmd/tk_bootstrap_github/","text":"tk bootstrap github \u00b6 Bootstrap toolkit components in a GitHub repository Synopsis \u00b6 The bootstrap github command creates the GitHub repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. tk bootstrap github [flags] Examples \u00b6 # Create a GitHub personal access token and export it as an env var export GITHUB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitHub organization tk bootstrap github --owner=<organization> --repository=<repo name> # Run bootstrap for a private repo and assign organization teams to it tk bootstrap github --owner=<organization> --repository=<repo name> --team=<team1 slug> --team=<team2 slug> # Run bootstrap for a repository path tk bootstrap github --owner=<organization> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account tk bootstrap github --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on GitHub Enterprise tk bootstrap github --owner=<organization> --repository=<repo name> --hostname=<domain> Options \u00b6 -h, --help help for github --hostname string GitHub hostname (default \"github.com\") --interval duration sync interval (default 1m0s) --owner string GitHub user or organization name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitHub repository name --team stringArray GitHub team to be given maintainer access Options inherited from parent commands \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") SEE ALSO \u00b6 tk bootstrap - Bootstrap toolkit components","title":"Bootstrap github"},{"location":"cmd/tk_bootstrap_github/#tk-bootstrap-github","text":"Bootstrap toolkit components in a GitHub repository","title":"tk bootstrap github"},{"location":"cmd/tk_bootstrap_github/#synopsis","text":"The bootstrap github command creates the GitHub repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. tk bootstrap github [flags]","title":"Synopsis"},{"location":"cmd/tk_bootstrap_github/#examples","text":"# Create a GitHub personal access token and export it as an env var export GITHUB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitHub organization tk bootstrap github --owner=<organization> --repository=<repo name> # Run bootstrap for a private repo and assign organization teams to it tk bootstrap github --owner=<organization> --repository=<repo name> --team=<team1 slug> --team=<team2 slug> # Run bootstrap for a repository path tk bootstrap github --owner=<organization> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account tk bootstrap github --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on GitHub Enterprise tk bootstrap github --owner=<organization> --repository=<repo name> --hostname=<domain>","title":"Examples"},{"location":"cmd/tk_bootstrap_github/#options","text":"-h, --help help for github --hostname string GitHub hostname (default \"github.com\") --interval duration sync interval (default 1m0s) --owner string GitHub user or organization name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitHub repository name --team stringArray GitHub team to be given maintainer access","title":"Options"},{"location":"cmd/tk_bootstrap_github/#options-inherited-from-parent-commands","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\")","title":"Options inherited from parent commands"},{"location":"cmd/tk_bootstrap_github/#see-also","text":"tk bootstrap - Bootstrap toolkit components","title":"SEE ALSO"},{"location":"cmd/tk_bootstrap_gitlab/","text":"tk bootstrap gitlab \u00b6 Bootstrap toolkit components in a GitLab repository Synopsis \u00b6 The bootstrap gitlab command creates the GitLab repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. tk bootstrap gitlab [flags] Examples \u00b6 # Create a GitLab API token and export it as an env var export GITLAB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitLab group tk bootstrap gitlab --owner=<group> --repository=<repo name> # Run bootstrap for a repository path tk bootstrap gitlab --owner=<group> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account tk bootstrap gitlab --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on a GitLab server tk bootstrap gitlab --owner=<group> --repository=<repo name> --hostname=<domain> Options \u00b6 -h, --help help for gitlab --hostname string GitLab hostname (default \"gitlab.com\") --interval duration sync interval (default 1m0s) --owner string GitLab user or group name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitLab repository name Options inherited from parent commands \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") SEE ALSO \u00b6 tk bootstrap - Bootstrap toolkit components","title":"Bootstrap gitlab"},{"location":"cmd/tk_bootstrap_gitlab/#tk-bootstrap-gitlab","text":"Bootstrap toolkit components in a GitLab repository","title":"tk bootstrap gitlab"},{"location":"cmd/tk_bootstrap_gitlab/#synopsis","text":"The bootstrap gitlab command creates the GitLab repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. tk bootstrap gitlab [flags]","title":"Synopsis"},{"location":"cmd/tk_bootstrap_gitlab/#examples","text":"# Create a GitLab API token and export it as an env var export GITLAB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitLab group tk bootstrap gitlab --owner=<group> --repository=<repo name> # Run bootstrap for a repository path tk bootstrap gitlab --owner=<group> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account tk bootstrap gitlab --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on a GitLab server tk bootstrap gitlab --owner=<group> --repository=<repo name> --hostname=<domain>","title":"Examples"},{"location":"cmd/tk_bootstrap_gitlab/#options","text":"-h, --help help for gitlab --hostname string GitLab hostname (default \"gitlab.com\") --interval duration sync interval (default 1m0s) --owner string GitLab user or group name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitLab repository name","title":"Options"},{"location":"cmd/tk_bootstrap_gitlab/#options-inherited-from-parent-commands","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\")","title":"Options inherited from parent commands"},{"location":"cmd/tk_bootstrap_gitlab/#see-also","text":"tk bootstrap - Bootstrap toolkit components","title":"SEE ALSO"},{"location":"cmd/tk_check/","text":"tk check \u00b6 Check requirements and installation Synopsis \u00b6 The check command will perform a series of checks to validate that the local environment is configured correctly and if the installed components are healthy. tk check [flags] Examples \u00b6 # Run pre-installation checks tk check --pre # Run installation checks tk check Options \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for check --pre only run pre-installation checks Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines","title":"Check"},{"location":"cmd/tk_check/#tk-check","text":"Check requirements and installation","title":"tk check"},{"location":"cmd/tk_check/#synopsis","text":"The check command will perform a series of checks to validate that the local environment is configured correctly and if the installed components are healthy. tk check [flags]","title":"Synopsis"},{"location":"cmd/tk_check/#examples","text":"# Run pre-installation checks tk check --pre # Run installation checks tk check","title":"Examples"},{"location":"cmd/tk_check/#options","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for check --pre only run pre-installation checks","title":"Options"},{"location":"cmd/tk_check/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_check/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/tk_completion/","text":"tk completion \u00b6 Generates bash completion scripts Synopsis \u00b6 Generates bash completion scripts tk completion [flags] Examples \u00b6 To load completion run . <(tk completion) To configure your bash shell to load completions for each session add to your bashrc # ~/.bashrc or ~/.profile . <(tk completion) Options \u00b6 -h, --help help for completion Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines","title":"Tk completion"},{"location":"cmd/tk_completion/#tk-completion","text":"Generates bash completion scripts","title":"tk completion"},{"location":"cmd/tk_completion/#synopsis","text":"Generates bash completion scripts tk completion [flags]","title":"Synopsis"},{"location":"cmd/tk_completion/#examples","text":"To load completion run . <(tk completion) To configure your bash shell to load completions for each session add to your bashrc # ~/.bashrc or ~/.profile . <(tk completion)","title":"Examples"},{"location":"cmd/tk_completion/#options","text":"-h, --help help for completion","title":"Options"},{"location":"cmd/tk_completion/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_completion/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/tk_create/","text":"tk create \u00b6 Create or update sources and resources Synopsis \u00b6 The create sub-commands generate sources and resources. Options \u00b6 --export export in YAML format to stdout -h, --help help for create --interval duration source sync interval (default 1m0s) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk create helmrelease - Create or update a HelmRelease resource tk create kustomization - Create or update a Kustomization resource tk create source - Create or update sources","title":"Create"},{"location":"cmd/tk_create/#tk-create","text":"Create or update sources and resources","title":"tk create"},{"location":"cmd/tk_create/#synopsis","text":"The create sub-commands generate sources and resources.","title":"Synopsis"},{"location":"cmd/tk_create/#options","text":"--export export in YAML format to stdout -h, --help help for create --interval duration source sync interval (default 1m0s)","title":"Options"},{"location":"cmd/tk_create/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_create/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk create helmrelease - Create or update a HelmRelease resource tk create kustomization - Create or update a Kustomization resource tk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/tk_create_helmrelease/","text":"tk create helmrelease \u00b6 Create or update a HelmRelease resource Synopsis \u00b6 The helmrelease create command generates a HelmRelease resource for a given HelmRepository source. tk create helmrelease [name] [flags] Examples \u00b6 # Create a HelmRelease from a source tk create hr podinfo \\ --interval=10m \\ --release-name=podinfo \\ --target-namespace=default \\ --source=podinfo \\ --chart-name=podinfo \\ --chart-version=\">4.0.0\" # Create a HelmRelease with values for a local YAML file tk create hr podinfo \\ --target-namespace=default \\ --source=podinfo \\ --chart-name=podinfo \\ --chart-version=4.0.5 \\ --values=./my-values.yaml # Create a HelmRelease definition on disk without applying it on the cluster tk create hr podinfo \\ --target-namespace=default \\ --source=podinfo \\ --chart-name=podinfo \\ --chart-version=4.0.5 \\ --values=./values.yaml \\ --export > podinfo-release.yaml Options \u00b6 --chart-name string Helm chart name --chart-version string Helm chart version, accepts semver range --depends-on stringArray HelmReleases that must be ready before this release can be installed -h, --help help for helmrelease --release-name string name used for the Helm release, defaults to a composition of '<target-namespace>-<hr-name>' --source string HelmRepository name --target-namespace string namespace to install this release, defaults to the HelmRelease namespace --values string local path to the values.yaml file Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk create - Create or update sources and resources","title":"Create helmrelease"},{"location":"cmd/tk_create_helmrelease/#tk-create-helmrelease","text":"Create or update a HelmRelease resource","title":"tk create helmrelease"},{"location":"cmd/tk_create_helmrelease/#synopsis","text":"The helmrelease create command generates a HelmRelease resource for a given HelmRepository source. tk create helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_create_helmrelease/#examples","text":"# Create a HelmRelease from a source tk create hr podinfo \\ --interval=10m \\ --release-name=podinfo \\ --target-namespace=default \\ --source=podinfo \\ --chart-name=podinfo \\ --chart-version=\">4.0.0\" # Create a HelmRelease with values for a local YAML file tk create hr podinfo \\ --target-namespace=default \\ --source=podinfo \\ --chart-name=podinfo \\ --chart-version=4.0.5 \\ --values=./my-values.yaml # Create a HelmRelease definition on disk without applying it on the cluster tk create hr podinfo \\ --target-namespace=default \\ --source=podinfo \\ --chart-name=podinfo \\ --chart-version=4.0.5 \\ --values=./values.yaml \\ --export > podinfo-release.yaml","title":"Examples"},{"location":"cmd/tk_create_helmrelease/#options","text":"--chart-name string Helm chart name --chart-version string Helm chart version, accepts semver range --depends-on stringArray HelmReleases that must be ready before this release can be installed -h, --help help for helmrelease --release-name string name used for the Helm release, defaults to a composition of '<target-namespace>-<hr-name>' --source string HelmRepository name --target-namespace string namespace to install this release, defaults to the HelmRelease namespace --values string local path to the values.yaml file","title":"Options"},{"location":"cmd/tk_create_helmrelease/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_create_helmrelease/#see-also","text":"tk create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_create_kustomization/","text":"tk create kustomization \u00b6 Create or update a Kustomization resource Synopsis \u00b6 The kustomization source create command generates a Kustomize resource for a given GitRepository source. tk create kustomization [name] [flags] Examples \u00b6 # Create a Kustomization resource from a source at a given path tk create kustomization contour \\ --source=contour \\ --path=\"./examples/contour/\" \\ --prune=true \\ --interval=10m \\ --validation=client \\ --health-check=\"Deployment/contour.projectcontour\" \\ --health-check=\"DaemonSet/envoy.projectcontour\" \\ --health-check-timeout=3m # Create a Kustomization resource that depends on the previous one tk create kustomization webapp \\ --depends-on=contour \\ --source=webapp \\ --path=\"./deploy/overlays/dev\" \\ --prune=true \\ --interval=5m \\ --validation=client # Create a Kustomization resource that runs under a service account tk create kustomization webapp \\ --source=webapp \\ --path=\"./deploy/overlays/staging\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --sa-name=reconclier \\ --sa-namespace=staging Options \u00b6 --depends-on stringArray Kustomization that must be ready before this Kustomization can be applied --health-check stringArray workload to be included in the health assessment, in the format '<kind>/<name>.<namespace>' --health-check-timeout duration timeout of health checking operations (default 2m0s) -h, --help help for kustomization --path string path to the directory containing the Kustomization file (default \"./\") --prune enable garbage collection --sa-name string service account name --sa-namespace string service account namespace --source string GitRepository name --validation string validate the manifests before applying them on the cluster, can be 'client' or 'server' Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk create - Create or update sources and resources","title":"Create kustomization"},{"location":"cmd/tk_create_kustomization/#tk-create-kustomization","text":"Create or update a Kustomization resource","title":"tk create kustomization"},{"location":"cmd/tk_create_kustomization/#synopsis","text":"The kustomization source create command generates a Kustomize resource for a given GitRepository source. tk create kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_create_kustomization/#examples","text":"# Create a Kustomization resource from a source at a given path tk create kustomization contour \\ --source=contour \\ --path=\"./examples/contour/\" \\ --prune=true \\ --interval=10m \\ --validation=client \\ --health-check=\"Deployment/contour.projectcontour\" \\ --health-check=\"DaemonSet/envoy.projectcontour\" \\ --health-check-timeout=3m # Create a Kustomization resource that depends on the previous one tk create kustomization webapp \\ --depends-on=contour \\ --source=webapp \\ --path=\"./deploy/overlays/dev\" \\ --prune=true \\ --interval=5m \\ --validation=client # Create a Kustomization resource that runs under a service account tk create kustomization webapp \\ --source=webapp \\ --path=\"./deploy/overlays/staging\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --sa-name=reconclier \\ --sa-namespace=staging","title":"Examples"},{"location":"cmd/tk_create_kustomization/#options","text":"--depends-on stringArray Kustomization that must be ready before this Kustomization can be applied --health-check stringArray workload to be included in the health assessment, in the format '<kind>/<name>.<namespace>' --health-check-timeout duration timeout of health checking operations (default 2m0s) -h, --help help for kustomization --path string path to the directory containing the Kustomization file (default \"./\") --prune enable garbage collection --sa-name string service account name --sa-namespace string service account namespace --source string GitRepository name --validation string validate the manifests before applying them on the cluster, can be 'client' or 'server'","title":"Options"},{"location":"cmd/tk_create_kustomization/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_create_kustomization/#see-also","text":"tk create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_create_source/","text":"tk create source \u00b6 Create or update sources Synopsis \u00b6 The create source sub-commands generate sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk create - Create or update sources and resources tk create source git - Create or update a GitRepository source tk create source helm - Create or update a HelmRepository source","title":"Create source"},{"location":"cmd/tk_create_source/#tk-create-source","text":"Create or update sources","title":"tk create source"},{"location":"cmd/tk_create_source/#synopsis","text":"The create source sub-commands generate sources.","title":"Synopsis"},{"location":"cmd/tk_create_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/tk_create_source/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_create_source/#see-also","text":"tk create - Create or update sources and resources tk create source git - Create or update a GitRepository source tk create source helm - Create or update a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/tk_create_source_git/","text":"tk create source git \u00b6 Create or update a GitRepository source Synopsis \u00b6 The create source git command generates a GitRepository resource and waits for it to sync. For Git over SSH, host and SSH keys are automatically generated and stored in a Kubernetes secret. For private Git repositories, the basic authentication credentials are stored in a Kubernetes secret. tk create source git [name] [flags] Examples \u00b6 # Create a source from a public Git repository master branch tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository pinned to specific git tag tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag=\"3.2.3\" # Create a source from a public Git repository tag that matches a semver range tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag-semver=\">=3.2.0 <3.3.0\" # Create a source from a Git repository using SSH authentication tk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository using SSH authentication and an # ECDSA P-521 curve public key tk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master \\ --ssh-key-algorithm=ecdsa \\ --ssh-ecdsa-curve=p521 # Create a source from a Git repository using basic authentication tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --username=username \\ --password=password Options \u00b6 --branch string git branch (default \"master\") -h, --help help for git -p, --password string basic authentication password --ssh-ecdsa-curve ecdsaCurve SSH ECDSA public key curve (p256, p384, p521) (default p384) --ssh-key-algorithm publicKeyAlgorithm SSH public key algorithm (rsa, ecdsa, ed25519) (default rsa) --ssh-rsa-bits rsaKeyBits SSH RSA public key bit size (multiplies of 8) (default 2048) --tag string git tag --tag-semver string git tag semver range --url string git address, e.g. ssh://git@host/org/repository -u, --username string basic authentication username Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk create source - Create or update sources","title":"Create source git"},{"location":"cmd/tk_create_source_git/#tk-create-source-git","text":"Create or update a GitRepository source","title":"tk create source git"},{"location":"cmd/tk_create_source_git/#synopsis","text":"The create source git command generates a GitRepository resource and waits for it to sync. For Git over SSH, host and SSH keys are automatically generated and stored in a Kubernetes secret. For private Git repositories, the basic authentication credentials are stored in a Kubernetes secret. tk create source git [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_create_source_git/#examples","text":"# Create a source from a public Git repository master branch tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository pinned to specific git tag tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag=\"3.2.3\" # Create a source from a public Git repository tag that matches a semver range tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag-semver=\">=3.2.0 <3.3.0\" # Create a source from a Git repository using SSH authentication tk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository using SSH authentication and an # ECDSA P-521 curve public key tk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master \\ --ssh-key-algorithm=ecdsa \\ --ssh-ecdsa-curve=p521 # Create a source from a Git repository using basic authentication tk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --username=username \\ --password=password","title":"Examples"},{"location":"cmd/tk_create_source_git/#options","text":"--branch string git branch (default \"master\") -h, --help help for git -p, --password string basic authentication password --ssh-ecdsa-curve ecdsaCurve SSH ECDSA public key curve (p256, p384, p521) (default p384) --ssh-key-algorithm publicKeyAlgorithm SSH public key algorithm (rsa, ecdsa, ed25519) (default rsa) --ssh-rsa-bits rsaKeyBits SSH RSA public key bit size (multiplies of 8) (default 2048) --tag string git tag --tag-semver string git tag semver range --url string git address, e.g. ssh://git@host/org/repository -u, --username string basic authentication username","title":"Options"},{"location":"cmd/tk_create_source_git/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_create_source_git/#see-also","text":"tk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/tk_create_source_helm/","text":"tk create source helm \u00b6 Create or update a HelmRepository source Synopsis \u00b6 The create source helm command generates a HelmRepository resource and waits for it to fetch the index. For private Helm repositories, the basic authentication credentials are stored in a Kubernetes secret. tk create source helm [name] [flags] Examples \u00b6 # Create a source from a public Helm repository tk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --interval=10m # Create a source from a Helm repository using basic authentication tk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --username=username \\ --password=password # Create a source from a Helm repository using TLS authentication tk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --cert-file=./cert.crt \\ --key-file=./key.crt \\ --ca-file=./ca.crt Options \u00b6 --ca-file string TLS authentication CA file path --cert-file string TLS authentication cert file path -h, --help help for helm --key-file string TLS authentication key file path -p, --password string basic authentication password --url string Helm repository address -u, --username string basic authentication username Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk create source - Create or update sources","title":"Create source helm"},{"location":"cmd/tk_create_source_helm/#tk-create-source-helm","text":"Create or update a HelmRepository source","title":"tk create source helm"},{"location":"cmd/tk_create_source_helm/#synopsis","text":"The create source helm command generates a HelmRepository resource and waits for it to fetch the index. For private Helm repositories, the basic authentication credentials are stored in a Kubernetes secret. tk create source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_create_source_helm/#examples","text":"# Create a source from a public Helm repository tk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --interval=10m # Create a source from a Helm repository using basic authentication tk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --username=username \\ --password=password # Create a source from a Helm repository using TLS authentication tk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --cert-file=./cert.crt \\ --key-file=./key.crt \\ --ca-file=./ca.crt","title":"Examples"},{"location":"cmd/tk_create_source_helm/#options","text":"--ca-file string TLS authentication CA file path --cert-file string TLS authentication cert file path -h, --help help for helm --key-file string TLS authentication key file path -p, --password string basic authentication password --url string Helm repository address -u, --username string basic authentication username","title":"Options"},{"location":"cmd/tk_create_source_helm/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_create_source_helm/#see-also","text":"tk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/tk_delete/","text":"tk delete \u00b6 Delete sources and resources Synopsis \u00b6 The delete sub-commands delete sources and resources. Options \u00b6 -h, --help help for delete -s, --silent delete resource without asking for confirmation Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk delete helmrelease - Delete a HelmRelease resource tk delete kustomization - Delete a Kustomization resource tk delete source - Delete sources","title":"Delete"},{"location":"cmd/tk_delete/#tk-delete","text":"Delete sources and resources","title":"tk delete"},{"location":"cmd/tk_delete/#synopsis","text":"The delete sub-commands delete sources and resources.","title":"Synopsis"},{"location":"cmd/tk_delete/#options","text":"-h, --help help for delete -s, --silent delete resource without asking for confirmation","title":"Options"},{"location":"cmd/tk_delete/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_delete/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk delete helmrelease - Delete a HelmRelease resource tk delete kustomization - Delete a Kustomization resource tk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/tk_delete_helmrelease/","text":"tk delete helmrelease \u00b6 Delete a HelmRelease resource Synopsis \u00b6 The delete helmrelease command removes the given HelmRelease from the cluster. tk delete helmrelease [name] [flags] Examples \u00b6 # Delete a Helm release and the Kubernetes resources created by it tk delete hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk delete - Delete sources and resources","title":"Delete helmrelease"},{"location":"cmd/tk_delete_helmrelease/#tk-delete-helmrelease","text":"Delete a HelmRelease resource","title":"tk delete helmrelease"},{"location":"cmd/tk_delete_helmrelease/#synopsis","text":"The delete helmrelease command removes the given HelmRelease from the cluster. tk delete helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_delete_helmrelease/#examples","text":"# Delete a Helm release and the Kubernetes resources created by it tk delete hr podinfo","title":"Examples"},{"location":"cmd/tk_delete_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/tk_delete_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_delete_helmrelease/#see-also","text":"tk delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_delete_kustomization/","text":"tk delete kustomization \u00b6 Delete a Kustomization resource Synopsis \u00b6 The delete kustomization command deletes the given Kustomization from the cluster. tk delete kustomization [name] [flags] Examples \u00b6 # Delete a kustomization and the Kubernetes resources created by it tk delete kustomization podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk delete - Delete sources and resources","title":"Delete kustomization"},{"location":"cmd/tk_delete_kustomization/#tk-delete-kustomization","text":"Delete a Kustomization resource","title":"tk delete kustomization"},{"location":"cmd/tk_delete_kustomization/#synopsis","text":"The delete kustomization command deletes the given Kustomization from the cluster. tk delete kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_delete_kustomization/#examples","text":"# Delete a kustomization and the Kubernetes resources created by it tk delete kustomization podinfo","title":"Examples"},{"location":"cmd/tk_delete_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/tk_delete_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_delete_kustomization/#see-also","text":"tk delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_delete_source/","text":"tk delete source \u00b6 Delete sources Synopsis \u00b6 The delete source sub-commands delete sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk delete - Delete sources and resources tk delete source git - Delete a GitRepository source tk delete source helm - Delete a HelmRepository source","title":"Delete source"},{"location":"cmd/tk_delete_source/#tk-delete-source","text":"Delete sources","title":"tk delete source"},{"location":"cmd/tk_delete_source/#synopsis","text":"The delete source sub-commands delete sources.","title":"Synopsis"},{"location":"cmd/tk_delete_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/tk_delete_source/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_delete_source/#see-also","text":"tk delete - Delete sources and resources tk delete source git - Delete a GitRepository source tk delete source helm - Delete a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/tk_delete_source_git/","text":"tk delete source git \u00b6 Delete a GitRepository source Synopsis \u00b6 The delete source git command deletes the given GitRepository from the cluster. tk delete source git [name] [flags] Examples \u00b6 # Delete a Git repository tk delete source git podinfo Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk delete source - Delete sources","title":"Delete source git"},{"location":"cmd/tk_delete_source_git/#tk-delete-source-git","text":"Delete a GitRepository source","title":"tk delete source git"},{"location":"cmd/tk_delete_source_git/#synopsis","text":"The delete source git command deletes the given GitRepository from the cluster. tk delete source git [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_delete_source_git/#examples","text":"# Delete a Git repository tk delete source git podinfo","title":"Examples"},{"location":"cmd/tk_delete_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/tk_delete_source_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_delete_source_git/#see-also","text":"tk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/tk_delete_source_helm/","text":"tk delete source helm \u00b6 Delete a HelmRepository source Synopsis \u00b6 The delete source helm command deletes the given HelmRepository from the cluster. tk delete source helm [name] [flags] Examples \u00b6 # Delete a Helm repository tk delete source helm podinfo Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk delete source - Delete sources","title":"Delete source helm"},{"location":"cmd/tk_delete_source_helm/#tk-delete-source-helm","text":"Delete a HelmRepository source","title":"tk delete source helm"},{"location":"cmd/tk_delete_source_helm/#synopsis","text":"The delete source helm command deletes the given HelmRepository from the cluster. tk delete source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_delete_source_helm/#examples","text":"# Delete a Helm repository tk delete source helm podinfo","title":"Examples"},{"location":"cmd/tk_delete_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/tk_delete_source_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_delete_source_helm/#see-also","text":"tk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/tk_export/","text":"tk export \u00b6 Export resources in YAML format Synopsis \u00b6 The export sub-commands export resources in YAML format. Options \u00b6 --all select all resources -h, --help help for export Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk export helmrelease - Export HelmRelease resources in YAML format tk export kustomization - Export Kustomization resources in YAML format tk export source - Export sources","title":"Export"},{"location":"cmd/tk_export/#tk-export","text":"Export resources in YAML format","title":"tk export"},{"location":"cmd/tk_export/#synopsis","text":"The export sub-commands export resources in YAML format.","title":"Synopsis"},{"location":"cmd/tk_export/#options","text":"--all select all resources -h, --help help for export","title":"Options"},{"location":"cmd/tk_export/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_export/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk export helmrelease - Export HelmRelease resources in YAML format tk export kustomization - Export Kustomization resources in YAML format tk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/tk_export_helmrelease/","text":"tk export helmrelease \u00b6 Export HelmRelease resources in YAML format Synopsis \u00b6 The export helmrelease command exports one or all HelmRelease resources in YAML format. tk export helmrelease [name] [flags] Examples \u00b6 # Export all HelmRelease resources tk export helmrelease --all > kustomizations.yaml # Export a HelmRelease tk export hr my-app > app-release.yaml Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk export - Export resources in YAML format","title":"Export helmrelease"},{"location":"cmd/tk_export_helmrelease/#tk-export-helmrelease","text":"Export HelmRelease resources in YAML format","title":"tk export helmrelease"},{"location":"cmd/tk_export_helmrelease/#synopsis","text":"The export helmrelease command exports one or all HelmRelease resources in YAML format. tk export helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_export_helmrelease/#examples","text":"# Export all HelmRelease resources tk export helmrelease --all > kustomizations.yaml # Export a HelmRelease tk export hr my-app > app-release.yaml","title":"Examples"},{"location":"cmd/tk_export_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/tk_export_helmrelease/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_export_helmrelease/#see-also","text":"tk export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/tk_export_kustomization/","text":"tk export kustomization \u00b6 Export Kustomization resources in YAML format Synopsis \u00b6 The export kustomization command exports one or all Kustomization resources in YAML format. tk export kustomization [name] [flags] Examples \u00b6 # Export all Kustomization resources tk export kustomization --all > kustomizations.yaml # Export a Kustomization tk export kustomization my-app > kustomization.yaml Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk export - Export resources in YAML format","title":"Export kustomization"},{"location":"cmd/tk_export_kustomization/#tk-export-kustomization","text":"Export Kustomization resources in YAML format","title":"tk export kustomization"},{"location":"cmd/tk_export_kustomization/#synopsis","text":"The export kustomization command exports one or all Kustomization resources in YAML format. tk export kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_export_kustomization/#examples","text":"# Export all Kustomization resources tk export kustomization --all > kustomizations.yaml # Export a Kustomization tk export kustomization my-app > kustomization.yaml","title":"Examples"},{"location":"cmd/tk_export_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/tk_export_kustomization/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_export_kustomization/#see-also","text":"tk export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/tk_export_source/","text":"tk export source \u00b6 Export sources Synopsis \u00b6 The export source sub-commands export sources in YAML format. Options \u00b6 -h, --help help for source --with-credentials include credential secrets Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk export - Export resources in YAML format tk export source git - Export GitRepository sources in YAML format tk export source helm - Export HelmRepository sources in YAML format","title":"Export source"},{"location":"cmd/tk_export_source/#tk-export-source","text":"Export sources","title":"tk export source"},{"location":"cmd/tk_export_source/#synopsis","text":"The export source sub-commands export sources in YAML format.","title":"Synopsis"},{"location":"cmd/tk_export_source/#options","text":"-h, --help help for source --with-credentials include credential secrets","title":"Options"},{"location":"cmd/tk_export_source/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_export_source/#see-also","text":"tk export - Export resources in YAML format tk export source git - Export GitRepository sources in YAML format tk export source helm - Export HelmRepository sources in YAML format","title":"SEE ALSO"},{"location":"cmd/tk_export_source_git/","text":"tk export source git \u00b6 Export GitRepository sources in YAML format Synopsis \u00b6 The export source git command exports on or all GitRepository sources in YAML format. tk export source git [name] [flags] Examples \u00b6 # Export all GitRepository sources tk export source git --all > sources.yaml # Export a GitRepository source including the SSH key pair or basic auth credentials tk export source git my-private-repo --with-credentials > source.yaml Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 tk export source - Export sources","title":"Export source git"},{"location":"cmd/tk_export_source_git/#tk-export-source-git","text":"Export GitRepository sources in YAML format","title":"tk export source git"},{"location":"cmd/tk_export_source_git/#synopsis","text":"The export source git command exports on or all GitRepository sources in YAML format. tk export source git [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_export_source_git/#examples","text":"# Export all GitRepository sources tk export source git --all > sources.yaml # Export a GitRepository source including the SSH key pair or basic auth credentials tk export source git my-private-repo --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/tk_export_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/tk_export_source_git/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/tk_export_source_git/#see-also","text":"tk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/tk_export_source_helm/","text":"tk export source helm \u00b6 Export HelmRepository sources in YAML format Synopsis \u00b6 The export source git command exports on or all HelmRepository sources in YAML format. tk export source helm [name] [flags] Examples \u00b6 # Export all HelmRepository sources tk export source helm --all > sources.yaml # Export a HelmRepository source including the basic auth credentials tk export source helm my-private-repo --with-credentials > source.yaml Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 tk export source - Export sources","title":"Export source helm"},{"location":"cmd/tk_export_source_helm/#tk-export-source-helm","text":"Export HelmRepository sources in YAML format","title":"tk export source helm"},{"location":"cmd/tk_export_source_helm/#synopsis","text":"The export source git command exports on or all HelmRepository sources in YAML format. tk export source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_export_source_helm/#examples","text":"# Export all HelmRepository sources tk export source helm --all > sources.yaml # Export a HelmRepository source including the basic auth credentials tk export source helm my-private-repo --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/tk_export_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/tk_export_source_helm/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/tk_export_source_helm/#see-also","text":"tk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/tk_get/","text":"tk get \u00b6 Get sources and resources Synopsis \u00b6 The get sub-commands print the statuses of sources and resources. Options \u00b6 -h, --help help for get Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk get helmreleases - Get HelmRelease statuses tk get kustomizations - Get Kustomization statuses tk get sources - Get source statuses","title":"Get"},{"location":"cmd/tk_get/#tk-get","text":"Get sources and resources","title":"tk get"},{"location":"cmd/tk_get/#synopsis","text":"The get sub-commands print the statuses of sources and resources.","title":"Synopsis"},{"location":"cmd/tk_get/#options","text":"-h, --help help for get","title":"Options"},{"location":"cmd/tk_get/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_get/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk get helmreleases - Get HelmRelease statuses tk get kustomizations - Get Kustomization statuses tk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/tk_get_helmreleases/","text":"tk get helmreleases \u00b6 Get HelmRelease statuses Synopsis \u00b6 The get helmreleases command prints the statuses of the resources. tk get helmreleases [flags] Examples \u00b6 # List all Helm releases and their status tk get helmreleases Options \u00b6 -h, --help help for helmreleases Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk get - Get sources and resources","title":"Get helmreleases"},{"location":"cmd/tk_get_helmreleases/#tk-get-helmreleases","text":"Get HelmRelease statuses","title":"tk get helmreleases"},{"location":"cmd/tk_get_helmreleases/#synopsis","text":"The get helmreleases command prints the statuses of the resources. tk get helmreleases [flags]","title":"Synopsis"},{"location":"cmd/tk_get_helmreleases/#examples","text":"# List all Helm releases and their status tk get helmreleases","title":"Examples"},{"location":"cmd/tk_get_helmreleases/#options","text":"-h, --help help for helmreleases","title":"Options"},{"location":"cmd/tk_get_helmreleases/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_get_helmreleases/#see-also","text":"tk get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_get_kustomizations/","text":"tk get kustomizations \u00b6 Get Kustomization statuses Synopsis \u00b6 The get kustomizations command prints the statuses of the resources. tk get kustomizations [flags] Examples \u00b6 # List all kustomizations and their status tk get kustomizations Options \u00b6 -h, --help help for kustomizations Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk get - Get sources and resources","title":"Get kustomizations"},{"location":"cmd/tk_get_kustomizations/#tk-get-kustomizations","text":"Get Kustomization statuses","title":"tk get kustomizations"},{"location":"cmd/tk_get_kustomizations/#synopsis","text":"The get kustomizations command prints the statuses of the resources. tk get kustomizations [flags]","title":"Synopsis"},{"location":"cmd/tk_get_kustomizations/#examples","text":"# List all kustomizations and their status tk get kustomizations","title":"Examples"},{"location":"cmd/tk_get_kustomizations/#options","text":"-h, --help help for kustomizations","title":"Options"},{"location":"cmd/tk_get_kustomizations/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_get_kustomizations/#see-also","text":"tk get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_get_sources/","text":"tk get sources \u00b6 Get source statuses Synopsis \u00b6 The get source sub-commands print the statuses of the sources. Options \u00b6 -h, --help help for sources Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk get - Get sources and resources tk get sources git - Get GitRepository source statuses tk get sources helm - Get HelmRepository source statuses","title":"Get sources"},{"location":"cmd/tk_get_sources/#tk-get-sources","text":"Get source statuses","title":"tk get sources"},{"location":"cmd/tk_get_sources/#synopsis","text":"The get source sub-commands print the statuses of the sources.","title":"Synopsis"},{"location":"cmd/tk_get_sources/#options","text":"-h, --help help for sources","title":"Options"},{"location":"cmd/tk_get_sources/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_get_sources/#see-also","text":"tk get - Get sources and resources tk get sources git - Get GitRepository source statuses tk get sources helm - Get HelmRepository source statuses","title":"SEE ALSO"},{"location":"cmd/tk_get_sources_git/","text":"tk get sources git \u00b6 Get GitRepository source statuses Synopsis \u00b6 The get sources git command prints the status of the GitRepository sources. tk get sources git [flags] Examples \u00b6 # List all Git repositories and their status tk get sources git Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk get sources - Get source statuses","title":"Get sources git"},{"location":"cmd/tk_get_sources_git/#tk-get-sources-git","text":"Get GitRepository source statuses","title":"tk get sources git"},{"location":"cmd/tk_get_sources_git/#synopsis","text":"The get sources git command prints the status of the GitRepository sources. tk get sources git [flags]","title":"Synopsis"},{"location":"cmd/tk_get_sources_git/#examples","text":"# List all Git repositories and their status tk get sources git","title":"Examples"},{"location":"cmd/tk_get_sources_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/tk_get_sources_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_get_sources_git/#see-also","text":"tk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/tk_get_sources_helm/","text":"tk get sources helm \u00b6 Get HelmRepository source statuses Synopsis \u00b6 The get sources helm command prints the status of the HelmRepository sources. tk get sources helm [flags] Examples \u00b6 # List all Helm repositories and their status tk get sources helm Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk get sources - Get source statuses","title":"Get sources helm"},{"location":"cmd/tk_get_sources_helm/#tk-get-sources-helm","text":"Get HelmRepository source statuses","title":"tk get sources helm"},{"location":"cmd/tk_get_sources_helm/#synopsis","text":"The get sources helm command prints the status of the HelmRepository sources. tk get sources helm [flags]","title":"Synopsis"},{"location":"cmd/tk_get_sources_helm/#examples","text":"# List all Helm repositories and their status tk get sources helm","title":"Examples"},{"location":"cmd/tk_get_sources_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/tk_get_sources_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_get_sources_helm/#see-also","text":"tk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/tk_install/","text":"tk install \u00b6 Install the toolkit components Synopsis \u00b6 The install command deploys the toolkit components in the specified namespace. If a previous version is installed, then an in-place upgrade will be performed. tk install [flags] Examples \u00b6 # Install the latest version in the gitops-systems namespace tk install --version=latest --namespace=gitops-systems # Dry-run install for a specific version and a series of components tk install --dry-run --version=v0.0.7 --components=\"source-controller,kustomize-controller\" # Dry-run install with manifests preview tk install --dry-run --verbose # Write install manifests to file tk install --export > gitops-system.yaml Options \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --dry-run only print the object that would be applied --export write the install manifests to stdout and exit -h, --help help for install --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --manifests string path to the manifest directory, dev only --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") -v, --version string toolkit version (default \"latest\") Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines","title":"Install"},{"location":"cmd/tk_install/#tk-install","text":"Install the toolkit components","title":"tk install"},{"location":"cmd/tk_install/#synopsis","text":"The install command deploys the toolkit components in the specified namespace. If a previous version is installed, then an in-place upgrade will be performed. tk install [flags]","title":"Synopsis"},{"location":"cmd/tk_install/#examples","text":"# Install the latest version in the gitops-systems namespace tk install --version=latest --namespace=gitops-systems # Dry-run install for a specific version and a series of components tk install --dry-run --version=v0.0.7 --components=\"source-controller,kustomize-controller\" # Dry-run install with manifests preview tk install --dry-run --verbose # Write install manifests to file tk install --export > gitops-system.yaml","title":"Examples"},{"location":"cmd/tk_install/#options","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --dry-run only print the object that would be applied --export write the install manifests to stdout and exit -h, --help help for install --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --manifests string path to the manifest directory, dev only --registry string container registry where the toolkit images are published (default \"docker.io/fluxcd\") -v, --version string toolkit version (default \"latest\")","title":"Options"},{"location":"cmd/tk_install/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_install/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/tk_reconcile/","text":"tk reconcile \u00b6 Reconcile sources and resources Synopsis \u00b6 The reconcile sub-commands trigger a reconciliation of sources and resources. Options \u00b6 -h, --help help for reconcile Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk reconcile helmrelease - Reconcile a HelmRelease resource tk reconcile kustomization - Reconcile a Kustomization resource tk reconcile source - Reconcile sources","title":"Reconcile"},{"location":"cmd/tk_reconcile/#tk-reconcile","text":"Reconcile sources and resources","title":"tk reconcile"},{"location":"cmd/tk_reconcile/#synopsis","text":"The reconcile sub-commands trigger a reconciliation of sources and resources.","title":"Synopsis"},{"location":"cmd/tk_reconcile/#options","text":"-h, --help help for reconcile","title":"Options"},{"location":"cmd/tk_reconcile/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_reconcile/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk reconcile helmrelease - Reconcile a HelmRelease resource tk reconcile kustomization - Reconcile a Kustomization resource tk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/tk_reconcile_helmrelease/","text":"tk reconcile helmrelease \u00b6 Reconcile a HelmRelease resource Synopsis \u00b6 The reconcile kustomization command triggers a reconciliation of a HelmRelease resource and waits for it to finish. tk reconcile helmrelease [name] [flags] Examples \u00b6 # Trigger a HelmRelease apply outside of the reconciliation interval tk reconcile hr podinfo # Trigger a reconciliation of the HelmRelease's source and apply changes tk reconcile hr podinfo --with-source Options \u00b6 -h, --help help for helmrelease --with-source reconcile HelmRelease source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk reconcile - Reconcile sources and resources","title":"Reconcile helmrelease"},{"location":"cmd/tk_reconcile_helmrelease/#tk-reconcile-helmrelease","text":"Reconcile a HelmRelease resource","title":"tk reconcile helmrelease"},{"location":"cmd/tk_reconcile_helmrelease/#synopsis","text":"The reconcile kustomization command triggers a reconciliation of a HelmRelease resource and waits for it to finish. tk reconcile helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_reconcile_helmrelease/#examples","text":"# Trigger a HelmRelease apply outside of the reconciliation interval tk reconcile hr podinfo # Trigger a reconciliation of the HelmRelease's source and apply changes tk reconcile hr podinfo --with-source","title":"Examples"},{"location":"cmd/tk_reconcile_helmrelease/#options","text":"-h, --help help for helmrelease --with-source reconcile HelmRelease source","title":"Options"},{"location":"cmd/tk_reconcile_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_reconcile_helmrelease/#see-also","text":"tk reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_reconcile_kustomization/","text":"tk reconcile kustomization \u00b6 Reconcile a Kustomization resource Synopsis \u00b6 The reconcile kustomization command triggers a reconciliation of a Kustomization resource and waits for it to finish. tk reconcile kustomization [name] [flags] Examples \u00b6 # Trigger a Kustomization apply outside of the reconciliation interval tk reconcile kustomization podinfo # Trigger a sync of the Kustomization's source and apply changes tk reconcile kustomization podinfo --with-source Options \u00b6 -h, --help help for kustomization --with-source reconcile kustomization source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk reconcile - Reconcile sources and resources","title":"Reconcile kustomization"},{"location":"cmd/tk_reconcile_kustomization/#tk-reconcile-kustomization","text":"Reconcile a Kustomization resource","title":"tk reconcile kustomization"},{"location":"cmd/tk_reconcile_kustomization/#synopsis","text":"The reconcile kustomization command triggers a reconciliation of a Kustomization resource and waits for it to finish. tk reconcile kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_reconcile_kustomization/#examples","text":"# Trigger a Kustomization apply outside of the reconciliation interval tk reconcile kustomization podinfo # Trigger a sync of the Kustomization's source and apply changes tk reconcile kustomization podinfo --with-source","title":"Examples"},{"location":"cmd/tk_reconcile_kustomization/#options","text":"-h, --help help for kustomization --with-source reconcile kustomization source","title":"Options"},{"location":"cmd/tk_reconcile_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_reconcile_kustomization/#see-also","text":"tk reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/tk_reconcile_source/","text":"tk reconcile source \u00b6 Reconcile sources Synopsis \u00b6 The reconcile source sub-commands trigger a reconciliation of sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk reconcile - Reconcile sources and resources tk reconcile source git - Reconcile a GitRepository source tk reconcile source helm - Reconcile a HelmRepository source","title":"Reconcile source"},{"location":"cmd/tk_reconcile_source/#tk-reconcile-source","text":"Reconcile sources","title":"tk reconcile source"},{"location":"cmd/tk_reconcile_source/#synopsis","text":"The reconcile source sub-commands trigger a reconciliation of sources.","title":"Synopsis"},{"location":"cmd/tk_reconcile_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/tk_reconcile_source/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_reconcile_source/#see-also","text":"tk reconcile - Reconcile sources and resources tk reconcile source git - Reconcile a GitRepository source tk reconcile source helm - Reconcile a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/tk_reconcile_source_git/","text":"tk reconcile source git \u00b6 Reconcile a GitRepository source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a GitRepository resource and waits for it to finish. tk reconcile source git [name] [flags] Examples \u00b6 # Trigger a git pull for an existing source tk reconcile source git podinfo Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk reconcile source - Reconcile sources","title":"Reconcile source git"},{"location":"cmd/tk_reconcile_source_git/#tk-reconcile-source-git","text":"Reconcile a GitRepository source","title":"tk reconcile source git"},{"location":"cmd/tk_reconcile_source_git/#synopsis","text":"The reconcile source command triggers a reconciliation of a GitRepository resource and waits for it to finish. tk reconcile source git [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_reconcile_source_git/#examples","text":"# Trigger a git pull for an existing source tk reconcile source git podinfo","title":"Examples"},{"location":"cmd/tk_reconcile_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/tk_reconcile_source_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_reconcile_source_git/#see-also","text":"tk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/tk_reconcile_source_helm/","text":"tk reconcile source helm \u00b6 Reconcile a HelmRepository source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a HelmRepository resource and waits for it to finish. tk reconcile source helm [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing source tk reconcile source helm podinfo Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk reconcile source - Reconcile sources","title":"Reconcile source helm"},{"location":"cmd/tk_reconcile_source_helm/#tk-reconcile-source-helm","text":"Reconcile a HelmRepository source","title":"tk reconcile source helm"},{"location":"cmd/tk_reconcile_source_helm/#synopsis","text":"The reconcile source command triggers a reconciliation of a HelmRepository resource and waits for it to finish. tk reconcile source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_reconcile_source_helm/#examples","text":"# Trigger a reconciliation for an existing source tk reconcile source helm podinfo","title":"Examples"},{"location":"cmd/tk_reconcile_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/tk_reconcile_source_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_reconcile_source_helm/#see-also","text":"tk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/tk_resume/","text":"tk resume \u00b6 Resume suspended resources Synopsis \u00b6 The resume sub-commands resume a suspended resource. Options \u00b6 -h, --help help for resume Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk resume helmrelease - Resume a suspended HelmRelease tk resume kustomization - Resume a suspended Kustomization","title":"Resume"},{"location":"cmd/tk_resume/#tk-resume","text":"Resume suspended resources","title":"tk resume"},{"location":"cmd/tk_resume/#synopsis","text":"The resume sub-commands resume a suspended resource.","title":"Synopsis"},{"location":"cmd/tk_resume/#options","text":"-h, --help help for resume","title":"Options"},{"location":"cmd/tk_resume/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_resume/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk resume helmrelease - Resume a suspended HelmRelease tk resume kustomization - Resume a suspended Kustomization","title":"SEE ALSO"},{"location":"cmd/tk_resume_helmrelease/","text":"tk resume helmrelease \u00b6 Resume a suspended HelmRelease Synopsis \u00b6 The resume command marks a previously suspended HelmRelease resource for reconciliation and waits for it to finish the apply. tk resume helmrelease [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Helm release tk resume hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk resume - Resume suspended resources","title":"Resume helmrelease"},{"location":"cmd/tk_resume_helmrelease/#tk-resume-helmrelease","text":"Resume a suspended HelmRelease","title":"tk resume helmrelease"},{"location":"cmd/tk_resume_helmrelease/#synopsis","text":"The resume command marks a previously suspended HelmRelease resource for reconciliation and waits for it to finish the apply. tk resume helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_resume_helmrelease/#examples","text":"# Resume reconciliation for an existing Helm release tk resume hr podinfo","title":"Examples"},{"location":"cmd/tk_resume_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/tk_resume_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_resume_helmrelease/#see-also","text":"tk resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/tk_resume_kustomization/","text":"tk resume kustomization \u00b6 Resume a suspended Kustomization Synopsis \u00b6 The resume command marks a previously suspended Kustomization resource for reconciliation and waits for it to finish the apply. tk resume kustomization [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Kustomization tk resume ks podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk resume - Resume suspended resources","title":"Resume kustomization"},{"location":"cmd/tk_resume_kustomization/#tk-resume-kustomization","text":"Resume a suspended Kustomization","title":"tk resume kustomization"},{"location":"cmd/tk_resume_kustomization/#synopsis","text":"The resume command marks a previously suspended Kustomization resource for reconciliation and waits for it to finish the apply. tk resume kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_resume_kustomization/#examples","text":"# Resume reconciliation for an existing Kustomization tk resume ks podinfo","title":"Examples"},{"location":"cmd/tk_resume_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/tk_resume_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_resume_kustomization/#see-also","text":"tk resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/tk_suspend/","text":"tk suspend \u00b6 Suspend resources Synopsis \u00b6 The suspend sub-commands suspend the reconciliation of a resource. Options \u00b6 -h, --help help for suspend Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines tk suspend helmrelease - Suspend reconciliation of HelmRelease tk suspend kustomization - Suspend reconciliation of Kustomization","title":"Suspend"},{"location":"cmd/tk_suspend/#tk-suspend","text":"Suspend resources","title":"tk suspend"},{"location":"cmd/tk_suspend/#synopsis","text":"The suspend sub-commands suspend the reconciliation of a resource.","title":"Synopsis"},{"location":"cmd/tk_suspend/#options","text":"-h, --help help for suspend","title":"Options"},{"location":"cmd/tk_suspend/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_suspend/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines tk suspend helmrelease - Suspend reconciliation of HelmRelease tk suspend kustomization - Suspend reconciliation of Kustomization","title":"SEE ALSO"},{"location":"cmd/tk_suspend_helmrelease/","text":"tk suspend helmrelease \u00b6 Suspend reconciliation of HelmRelease Synopsis \u00b6 The suspend command disables the reconciliation of a HelmRelease resource. tk suspend helmrelease [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Helm release tk suspend hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk suspend - Suspend resources","title":"Suspend helmrelease"},{"location":"cmd/tk_suspend_helmrelease/#tk-suspend-helmrelease","text":"Suspend reconciliation of HelmRelease","title":"tk suspend helmrelease"},{"location":"cmd/tk_suspend_helmrelease/#synopsis","text":"The suspend command disables the reconciliation of a HelmRelease resource. tk suspend helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_suspend_helmrelease/#examples","text":"# Suspend reconciliation for an existing Helm release tk suspend hr podinfo","title":"Examples"},{"location":"cmd/tk_suspend_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/tk_suspend_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_suspend_helmrelease/#see-also","text":"tk suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/tk_suspend_kustomization/","text":"tk suspend kustomization \u00b6 Suspend reconciliation of Kustomization Synopsis \u00b6 The suspend command disables the reconciliation of a Kustomization resource. tk suspend kustomization [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Kustomization tk suspend ks podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk suspend - Suspend resources","title":"Suspend kustomization"},{"location":"cmd/tk_suspend_kustomization/#tk-suspend-kustomization","text":"Suspend reconciliation of Kustomization","title":"tk suspend kustomization"},{"location":"cmd/tk_suspend_kustomization/#synopsis","text":"The suspend command disables the reconciliation of a Kustomization resource. tk suspend kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/tk_suspend_kustomization/#examples","text":"# Suspend reconciliation for an existing Kustomization tk suspend ks podinfo","title":"Examples"},{"location":"cmd/tk_suspend_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/tk_suspend_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_suspend_kustomization/#see-also","text":"tk suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/tk_uninstall/","text":"tk uninstall \u00b6 Uninstall the toolkit components Synopsis \u00b6 The uninstall command removes the namespace, cluster roles, cluster role bindings and CRDs from the cluster. tk uninstall [flags] Examples \u00b6 # Dry-run uninstall of all components tk uninstall --dry-run --namespace=gitops-system # Uninstall all components and delete custom resource definitions tk uninstall --resources --crds --namespace=gitops-system Options \u00b6 --crds removes all CRDs previously installed --dry-run only print the object that would be deleted -h, --help help for uninstall --resources removes custom resources such as Kustomizations, GitRepositories and HelmRepositories -s, --silent delete components without asking for confirmation Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 tk - Command line utility for assembling Kubernetes CD pipelines","title":"Uninstall"},{"location":"cmd/tk_uninstall/#tk-uninstall","text":"Uninstall the toolkit components","title":"tk uninstall"},{"location":"cmd/tk_uninstall/#synopsis","text":"The uninstall command removes the namespace, cluster roles, cluster role bindings and CRDs from the cluster. tk uninstall [flags]","title":"Synopsis"},{"location":"cmd/tk_uninstall/#examples","text":"# Dry-run uninstall of all components tk uninstall --dry-run --namespace=gitops-system # Uninstall all components and delete custom resource definitions tk uninstall --resources --crds --namespace=gitops-system","title":"Examples"},{"location":"cmd/tk_uninstall/#options","text":"--crds removes all CRDs previously installed --dry-run only print the object that would be deleted -h, --help help for uninstall --resources removes custom resources such as Kustomizations, GitRepositories and HelmRepositories -s, --silent delete components without asking for confirmation","title":"Options"},{"location":"cmd/tk_uninstall/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --namespace string the namespace scope for this operation (default \"gitops-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/tk_uninstall/#see-also","text":"tk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"components/helm/api/","text":"HelmRelease API reference Packages: helm.toolkit.fluxcd.io/v2alpha1 helm.toolkit.fluxcd.io/v2alpha1 Package v2alpha1 contains API Schema definitions for the helm v2alpha1 API group Resource Types: HelmRelease HelmRelease HelmRelease is the Schema for the helmreleases API Field Description apiVersion string helm.toolkit.fluxcd.io/v2alpha1 kind string HelmRelease metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmReleaseSpec chart HelmChartTemplate Chart defines the Helm chart name, version and repository. interval Kubernetes meta/v1.Duration Interval at which to reconcile the Helm release. suspend bool (Optional) Suspend tells the reconciler to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false. releaseName string (Optional) ReleaseName used for the Helm release. Defaults to a composition of \u2018[TargetNamespace-]Name\u2019. targetNamespace string (Optional) TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease. dependsOn []string (Optional) DependsOn may contain a list of HelmReleases that must be ready before this HelmRelease can be reconciled. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to \u20185m0s\u2019. maxHistory int (Optional) MaxHistory is the number of revisions saved by Helm for this release. Use \u20180\u2019 for an unlimited number of revisions; defaults to \u201810\u2019. install Install (Optional) Install holds the configuration for Helm install actions for this release. upgrade Upgrade (Optional) Upgrade holds the configuration for Helm upgrade actions for this release. test Test (Optional) Test holds the configuration for Helm test actions for this release. rollback Rollback (Optional) Rollback holds the configuration for Helm rollback actions for this release. uninstall Uninstall (Optional) Uninstall holds the configuration for Helm uninstall actions for this release. valuesFrom []ValuesReference ValuesFrom holds references to resources containing Helm values, and information about how they should be merged. values k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1.JSON (Optional) Values holds the values for this Helm release. status HelmReleaseStatus Condition ( Appears on: HelmReleaseStatus ) Condition contains condition information for a HelmRelease. Field Description type string Type of the condition, one of (\u2018Ready\u2019, \u2018Install\u2019, \u2018Upgrade\u2019, \u2018Test\u2019, \u2018Rollback\u2019, \u2018Uninstall\u2019). status Kubernetes core/v1.ConditionStatus Status of the condition, one of (\u2018True\u2019, \u2018False\u2019, \u2018Unknown\u2019). lastTransitionTime Kubernetes meta/v1.Time LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. CrossNamespaceObjectReference ( Appears on: HelmChartTemplate ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level. Field Description apiVersion string (Optional) APIVersion of the referent. kind string Kind of the referent. name string Name of the referent. namespace string (Optional) Namespace of the referent. HelmChartTemplate ( Appears on: HelmReleaseSpec ) HelmChartTemplate defines the template from which the controller will generate a HelmChart object in the same namespace as the HelmRepository. Field Description name string Name of the Helm chart, as made available by the referenced Helm repository. version string (Optional) Version semver expression, defaults to latest when omitted. sourceRef CrossNamespaceObjectReference The name and namespace of the source HelmRepository the chart is available at. interval Kubernetes meta/v1.Duration (Optional) Interval at which to check the Helm repository for chart updates. Defaults to \u2018HelmReleaseSpec.Interval\u2019. HelmReleaseSpec ( Appears on: HelmRelease ) HelmReleaseSpec defines the desired state of HelmRelease. Field Description chart HelmChartTemplate Chart defines the Helm chart name, version and repository. interval Kubernetes meta/v1.Duration Interval at which to reconcile the Helm release. suspend bool (Optional) Suspend tells the reconciler to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false. releaseName string (Optional) ReleaseName used for the Helm release. Defaults to a composition of \u2018[TargetNamespace-]Name\u2019. targetNamespace string (Optional) TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease. dependsOn []string (Optional) DependsOn may contain a list of HelmReleases that must be ready before this HelmRelease can be reconciled. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to \u20185m0s\u2019. maxHistory int (Optional) MaxHistory is the number of revisions saved by Helm for this release. Use \u20180\u2019 for an unlimited number of revisions; defaults to \u201810\u2019. install Install (Optional) Install holds the configuration for Helm install actions for this release. upgrade Upgrade (Optional) Upgrade holds the configuration for Helm upgrade actions for this release. test Test (Optional) Test holds the configuration for Helm test actions for this release. rollback Rollback (Optional) Rollback holds the configuration for Helm rollback actions for this release. uninstall Uninstall (Optional) Uninstall holds the configuration for Helm uninstall actions for this release. valuesFrom []ValuesReference ValuesFrom holds references to resources containing Helm values, and information about how they should be merged. values k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1.JSON (Optional) Values holds the values for this Helm release. HelmReleaseStatus ( Appears on: HelmRelease ) HelmReleaseStatus defines the observed state of HelmRelease Field Description observedGeneration int64 (Optional) ObservedGeneration is the last reconciled generation. conditions []Condition (Optional) Conditions holds the conditions for the HelmRelease. lastAppliedRevision string (Optional) LastAppliedRevision is the revision of the last successfully applied source. lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. lastAttemptedValuesChecksum string (Optional) LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last reconciliation attempt. lastReleaseRevision int (Optional) LastReleaseRevision is the revision of the last successful Helm release. helmChart string (Optional) HelmChart is the namespaced name of the HelmChart resource created by the controller for the HelmRelease. failures int64 (Optional) Failures is the reconciliation failure count. It is reset after a successful reconciliation. Install ( Appears on: HelmReleaseSpec ) Install holds the configuration for Helm install actions. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm install action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm install has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm install action. disableOpenAPIValidation bool (Optional) DisableOpenAPIValidation prevents the Helm install action from validating rendered templates against the Kubernetes OpenAPI Schema. replace bool (Optional) Replace tells the Helm install action to re-use the \u2018ReleaseName\u2019, but only if that name is a deleted release which remains in the history. skipCRDs bool (Optional) SkipCRDs tells the Helm install action to not install any CRDs. By default, CRDs are installed if not already present. Rollback ( Appears on: HelmReleaseSpec ) Rollback holds the configuration for Helm rollback actions. Field Description enable bool (Optional) Enable enables Helm rollback actions for this release after an Helm install or upgrade action failure. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm rollback action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm rollback has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm rollback action. recreate bool (Optional) Recreate performs pod restarts for the resource if applicable. force bool (Optional) Force forces resource updates through a replacement strategy. cleanupOnFail bool (Optional) CleanupOnFail allows deletion of new resources created during the Helm rollback action when it fails. Test ( Appears on: HelmReleaseSpec ) Test holds the configuration for Helm test actions. Field Description enable bool (Optional) Enable enables Helm test actions for this release after an Helm install or upgrade action has been performed. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation during the performance of a Helm test action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. Uninstall ( Appears on: HelmReleaseSpec ) Uninstall holds the configuration for Helm uninstall actions. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm uninstall action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm rollback action. keepHistory bool (Optional) KeepHistory tells Helm to remove all associated resources and mark the release as deleted, but retain the release history. Unsortable ( [][]string alias) Upgrade ( Appears on: HelmReleaseSpec ) Upgrade holds the configuration for Helm upgrade actions. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm upgrade action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. maxRetries int (Optional) MaxRetries is the number of retries that should be attempted on failures before bailing. Defaults to \u20180\u2019, a negative integer equals to unlimited retries. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm upgrade has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm upgrade action. disableOpenAPIValidation bool (Optional) DisableOpenAPIValidation prevents the Helm upgrade action from validating rendered templates against the Kubernetes OpenAPI Schema. force bool (Optional) Force forces resource updates through a replacement strategy. preserveValues bool (Optional) PreserveValues will make Helm reuse the last release\u2019s values and merge in overrides from \u2018Values\u2019. Setting this flag makes the HelmRelease non-declarative. cleanupOnFail bool (Optional) CleanupOnFail allows deletion of new resources created during the Helm upgrade action when it fails. ValuesReference ( Appears on: HelmReleaseSpec ) ValuesReference contains a reference to a resource containing Helm values, and optionally the key they can be found at. Field Description kind string Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019). name string Name of the values referent. Should reside in the same namespace as the referring resource. valuesKey string (Optional) ValuesKey is the key in the referent the values can be found at. Defaults to \u2018values.yaml\u2019. This page was automatically generated with gen-crd-api-reference-docs","title":"Helm API Reference"},{"location":"components/helm/controller/","text":"Helm Controller \u00b6 The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests. The desired state of a Helm release is described through a Kubernetes Custom Resource named HelmRelease . Based on the creation, mutation or removal of a HelmRelease resource in the cluster, Helm actions are performed by the controller. Features: Watches for HelmRelease objects and generates HelmChart objects Fetches artifacts produced by source-controller from HelmChart objects Watches HelmChart objects for revision changes (semver ranges) Performs Helm v3 actions including Helm tests as configured in the HelmRelease objects Runs Helm install/upgrade in a specific order, taking into account the depends-on relationship Prunes Helm releases removed from cluster (garbage collection) Reports Helm releases status (alerting provided by notification-controller ) Links: Source code fluxcd/helm-controller Specification docs","title":"Overview"},{"location":"components/helm/controller/#helm-controller","text":"The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests. The desired state of a Helm release is described through a Kubernetes Custom Resource named HelmRelease . Based on the creation, mutation or removal of a HelmRelease resource in the cluster, Helm actions are performed by the controller. Features: Watches for HelmRelease objects and generates HelmChart objects Fetches artifacts produced by source-controller from HelmChart objects Watches HelmChart objects for revision changes (semver ranges) Performs Helm v3 actions including Helm tests as configured in the HelmRelease objects Runs Helm install/upgrade in a specific order, taking into account the depends-on relationship Prunes Helm releases removed from cluster (garbage collection) Reports Helm releases status (alerting provided by notification-controller ) Links: Source code fluxcd/helm-controller Specification docs","title":"Helm Controller"},{"location":"components/helm/helmreleases/","text":"Helm Releases \u00b6 The HelmRelease API defines a resource for automated controller driven Helm actions. Specification \u00b6 A helmrelease object defines the source of a Helm chart by referencing an object managed by source-controller , the interval reconciliation should happen at, and a set of options to control the settings of the automated Helm actions that are being performed. // HelmReleaseSpec defines the desired state of HelmRelease. type HelmReleaseSpec struct { // Chart defines the Helm chart name, version and repository. // +required Chart HelmChartTemplate `json:\"chart\"` // Interval at which to reconcile the Helm release. // +required Interval metav1 . Duration `json:\"interval\"` // Suspend tells the reconciler to suspend reconciliation for this HelmRelease, // it does not apply to already started reconciliations. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // ReleaseName used for the Helm release. Defaults to a composition of // '[TargetNamespace-]Name'. // +optional ReleaseName string `json:\"releaseName,omitempty\"` // TargetNamespace to target when performing operations for the HelmRelease. // Defaults to the namespace of the HelmRelease. // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // DependsOn may contain a list of HelmReleases that must be ready before this // HelmRelease can be reconciled. // +optional DependsOn [] string `json:\"dependsOn,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm action. Defaults to '5m0s'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // MaxHistory is the number of revisions saved by Helm for this release. // Use '0' for an unlimited number of revisions; defaults to '10'. // +optional MaxHistory * int `json:\"maxHistory,omitempty\"` // Install holds the configuration for Helm install actions for this release. // +optional Install Install `json:\"install,omitempty\"` // Upgrade holds the configuration for Helm upgrade actions for this release. // +optional Upgrade Upgrade `json:\"upgrade,omitempty\"` // Test holds the configuration for Helm test actions for this release. // +optional Test Test `json:\"test,omitempty\"` // Rollback holds the configuration for Helm rollback actions for this release. // +optional Rollback Rollback `json:\"rollback,omitempty\"` // Uninstall holds the configuration for Helm uninstall actions for this release. // +optional Uninstall Uninstall `json:\"uninstall,omitempty\"` // ValuesFrom holds references to resources containing Helm values, and information // about how they should be merged. ValuesFrom [] ValuesReference `json:\"valuesFrom,omitempty\" // Values holds the values for this Helm release. // +optional Values apiextensionsv1.JSON ` json : \"values,omitempty\"` } // HelmChartTemplate defines the template from which the controller // will generate a HelmChart object in the same namespace as the HelmRepository. type HelmChartTemplate struct { // Name of the Helm chart, as made available by the referenced Helm repository. // +required Name string ` json : \"name\"` // Version semver expression, defaults to latest when omitted. // +optional Version string ` json : \"version,omitempty\"` // The name and namespace of the source HelmRepository the chart is available at. // +required SourceRef CrossNamespaceObjectReference ` json : \"sourceRef\"` // Interval at which to check the Helm repository for chart updates. // Defaults to 'HelmReleaseSpec.Interval'. // +optional Interval *metav1.Duration ` json : \"interval,omitempty\"` } // Install holds the configuration for Helm install actions. type Install struct { // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm install action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a // Helm install has been performed. // +optional DisableWait bool ` json : \"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm install action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm install action from // validating rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool ` json : \"disableOpenAPIValidation,omitempty\"` // Replace tells the Helm install action to re-use the 'ReleaseName', but // only if that name is a deleted release which remains in the history. // +optional Replace bool ` json : \"replace,omitempty\"` // SkipCRDs tells the Helm install action to not install any CRDs. By default, // CRDs are installed if not already present. // +optional SkipCRDs bool ` json : \"skipCRDs,omitempty\"` } // Upgrade holds the configuration for Helm upgrade actions. type Upgrade struct { // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm upgrade action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // MaxRetries is the number of retries that should be attempted on failures before // bailing. Defaults to '0', a negative integer equals to unlimited retries. // +optional MaxRetries int ` json : \"maxRetries,omitempty\"` // DisableWait disables the waiting for resources to be ready after a // Helm upgrade has been performed. // +optional DisableWait bool ` json : \"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm upgrade action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm upgrade action from // validating rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool ` json : \"disableOpenAPIValidation,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool ` json : \"force,omitempty\"` // PreserveValues will make Helm reuse the last release's values and merge // in overrides from 'Values'. Setting this flag makes the HelmRelease // non-declarative. // +optional PreserveValues bool ` json : \"preserveValues,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // upgrade action when it fails. // +optional CleanupOnFail bool ` json : \"cleanupOnFail,omitempty\"` } // Test holds the configuration for Helm test actions. type Test struct { // Enable enables Helm test actions for this release after an // Helm install or upgrade action has been performed. // +optional Enable bool ` json : \"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation // during the performance of a Helm test action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` } // Rollback holds the configuration for Helm rollback actions. type Rollback struct { // Enable enables Helm rollback actions for this release after an // Helm install or upgrade action failure. // +optional Enable bool ` json : \"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm rollback action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a // Helm rollback has been performed. // +optional DisableWait bool ` json : \"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // Recreate performs pod restarts for the resource if applicable. // +optional Recreate bool ` json : \"recreate,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool ` json : \"force,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // rollback action when it fails. // +optional CleanupOnFail bool ` json : \"cleanupOnFail,omitempty\"` } // Uninstall holds the configuration for Helm uninstall actions. type Uninstall struct { // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm uninstall action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // KeepHistory tells Helm to remove all associated resources and mark the release // as deleted, but retain the release history. // +optional KeepHistory bool ` json : \"keepHistory,omitempty\" ` } Reference types: // CrossNamespaceObjectReference contains enough information to let you locate the // typed referenced object at cluster level. type CrossNamespaceObjectReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent. // +kubebuilder:validation:Enum=HelmRepository // +required Kind string `json:\"kind,omitempty\"` // Name of the referent. // +required Name string `json:\"name\"` // Namespace of the referent. // +optional Namespace string `json:\"namespace,omitempty\"` } // ValuesReference contains a reference to a resource containing Helm values, // and optionally the key they can be found at. type ValuesReference struct { // Kind of the values referent, valid values are ('Secret', 'ConfigMap'). // +kubebuilder:validation:Enum=Secret;ConfigMap // +required Kind string `json:\"kind\"` // Name of the values referent. Should reside in the same namespace as the // referring resource. // +required Name string `json:\"name\"` // ValuesKey is the key in the referent the values can be found at. // Defaults to 'values.yaml'. // +optional ValuesKey string `json:\"valuesKey,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that the HelmRelease has been successfully reconciled. ReadyCondition string = \"Ready\" // InstalledCondition represents the fact that the HelmRelease has been successfully installed. InstalledCondition string = \"Installed\" // UpgradedCondition represents the fact that the HelmRelease has been successfully upgraded. UpgradedCondition string = \"Upgraded\" // TestedCondition represents the fact that the HelmRelease has been successfully tested. TestedCondition string = \"Tested\" // RolledBackCondition represents the fact that the HelmRelease has been successfully rolled back. RolledBackCondition string = \"RolledBack\" // UninstalledCondition represents the fact that the HelmRelease has been successfully uninstalled. UninstalledCondition string = \"Uninstalled\" ) Status condition reasons: const ( // ReconciliationSucceededReason represents the fact that the reconciliation of the release has succeeded. ReconciliationSucceededReason string = \"ReconciliationSucceeded\" // ReconciliationFailedReason represents the fact that the reconciliation of the release has failed. ReconciliationFailedReason string = \"ReconciliationFailed\" // InstallSucceededReason represents the fact that the Helm install for the release succeeded. InstallSucceededReason string = \"InstallSucceeded\" // InstallFailedReason represents the fact that the Helm install for the release failed. InstallFailedReason string = \"InstallFailed\" // UpgradeSucceededReason represents the fact that the Helm upgrade for the release succeed. UpgradeSucceededReason string = \"UpgradeSucceeded\" // UpgradeFailedReason represents the fact that the Helm upgrade for the release failed. UpgradeFailedReason string = \"UpgradeFailed\" // TestFailedReason represents the fact that the Helm test for the release failed. TestSucceededReason string = \"TestSucceeded\" // TestFailedReason represents the fact that the Helm test for the release failed. TestFailedReason string = \"TestFailed\" // RollbackSucceededReason represents the fact that the Helm rollback for the release succeeded. RollbackSucceededReason string = \"RollbackSucceeded\" // RollbackFailedReason represents the fact that the Helm test for the release failed. RollbackFailedReason string = \"RollbackFailed\" // UninstallSucceededReason represents the fact that the Helm uninstall for the release succeeded. UninstallSucceededReason string = \"UninstallSucceeded\" // UninstallFailedReason represents the fact that the Helm uninstall for the release failed. UninstallFailedReason string = \"UninstallFailed\" // ArtifactFailedReason represents the fact that the artifact download for the release failed. ArtifactFailedReason string = \"ArtifactFailed\" // InitFailedReason represents the fact that the initialization of the Helm configuration failed. InitFailedReason string = \"InitFailed\" // ProgressingReason represents the fact that the reconciliation for the resource is underway. ProgressingReason string = \"Progressing\" // DependencyNotReadyReason represents the fact that the one of the dependencies is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // SuspendedReason represents the fact that the reconciliation of the HelmRelease is suspended. SuspendedReason string = \"Suspended\" ) Source reference \u00b6 The HelmRelease spec.chart.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a new release. Supported source types: HelmRepository Reconciliation \u00b6 The HelmRelease spec.interval tells the reconciler at which interval to reconcile the release. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The reconcilation can be suspended by setting spec.susped to true . The reconciler can be told to reconcile the HelmRelease outside of the specified interval by annotating the object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the specified schedule. ReconcileAtAnnotation string = \"fluxcd.io/reconcileAt\" ) On-demand execution example: kubectl annotate --overwrite helmrelease/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \" HelmRelease dependencies \u00b6 When applying a HelmRelease , you may need to make sure other releases exist before the release is reconciled. For example, because your chart relies on the presence of a Custom Resource Definition installed by another HelmRelease . With spec.dependsOn you can specify that the execution of a HelmRelease follows another. When you add dependsOn entries to a HelmRelease , that HelmRelease is reconciled only after all of its dependencies are ready. The readiness state of a HelmRelease is determined by its last apply status condition. Assuming two HelmRelease resources: backend - contains the backend of the application frontend - contains the frontend of the application and relies on the backend apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : backend spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m test : enable : true rollback : enable : true values : service : grpcService : backend resources : requests : cpu : 100m memory : 64Mi --- apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : frontend spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m dependsOn : - backend test : enable : true rollback : enable : true values : backend : http://backend-podinfo:9898/echo resources : requests : cpu : 100m memory : 64Mi Note that circular dependencies between HelmRelease resources must be avoided, otherwise the interdependent HelmRelease resources will never be reconciled. Enabling Helm rollback actions \u00b6 From time to time an Helm upgrade made by the helm-controller may fail, automatically recovering from this via a Helm rollback action is possible by enabling rollbacks for the HelmRelease . apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m rollback : enable : true values : resources : requests : cpu : 100m memory : 64Mi At present, rollbacks are only supported for failed upgrades. Rollback support for other failed actions (i.e. tests) is in the scope of the controller but awaits a proper design. Enabling Helm test actions \u00b6 To make the controller run the Helm tests available for your chart after a successful Helm install or upgrade, spec.test.enable should be set to true . apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m test : enable : true values : resources : requests : cpu : 100m memory : 64Mi At present, failed tests do not mark the HelmRelease as not Ready . Making this configurable is in the scope of the controller but awaits a proper design, as well as running them on a schedule or for other actions than a successful Helm install or upgrade. Status \u00b6 When the controller completes a reconciliation, it reports the result in the status sub-resource. A successful reconciliation sets the Ready condition to true : status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm installation succeeded reason : InstallSucceeded status : \"True\" type : Install - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2 You can wait for the helm-controller to complete a reconciliation with: kubectl wait helmrelease/podinfo --for = condition = ready A failed reconciliation sets the Ready condition to false : status : conditions : - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Upgrade - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : release reconciliation failed reason : ReconciliationFailed status : \"False\" type : Ready failures : 1 lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 3","title":"HelmRelease CRD"},{"location":"components/helm/helmreleases/#helm-releases","text":"The HelmRelease API defines a resource for automated controller driven Helm actions.","title":"Helm Releases"},{"location":"components/helm/helmreleases/#specification","text":"A helmrelease object defines the source of a Helm chart by referencing an object managed by source-controller , the interval reconciliation should happen at, and a set of options to control the settings of the automated Helm actions that are being performed. // HelmReleaseSpec defines the desired state of HelmRelease. type HelmReleaseSpec struct { // Chart defines the Helm chart name, version and repository. // +required Chart HelmChartTemplate `json:\"chart\"` // Interval at which to reconcile the Helm release. // +required Interval metav1 . Duration `json:\"interval\"` // Suspend tells the reconciler to suspend reconciliation for this HelmRelease, // it does not apply to already started reconciliations. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // ReleaseName used for the Helm release. Defaults to a composition of // '[TargetNamespace-]Name'. // +optional ReleaseName string `json:\"releaseName,omitempty\"` // TargetNamespace to target when performing operations for the HelmRelease. // Defaults to the namespace of the HelmRelease. // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // DependsOn may contain a list of HelmReleases that must be ready before this // HelmRelease can be reconciled. // +optional DependsOn [] string `json:\"dependsOn,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm action. Defaults to '5m0s'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // MaxHistory is the number of revisions saved by Helm for this release. // Use '0' for an unlimited number of revisions; defaults to '10'. // +optional MaxHistory * int `json:\"maxHistory,omitempty\"` // Install holds the configuration for Helm install actions for this release. // +optional Install Install `json:\"install,omitempty\"` // Upgrade holds the configuration for Helm upgrade actions for this release. // +optional Upgrade Upgrade `json:\"upgrade,omitempty\"` // Test holds the configuration for Helm test actions for this release. // +optional Test Test `json:\"test,omitempty\"` // Rollback holds the configuration for Helm rollback actions for this release. // +optional Rollback Rollback `json:\"rollback,omitempty\"` // Uninstall holds the configuration for Helm uninstall actions for this release. // +optional Uninstall Uninstall `json:\"uninstall,omitempty\"` // ValuesFrom holds references to resources containing Helm values, and information // about how they should be merged. ValuesFrom [] ValuesReference `json:\"valuesFrom,omitempty\" // Values holds the values for this Helm release. // +optional Values apiextensionsv1.JSON ` json : \"values,omitempty\"` } // HelmChartTemplate defines the template from which the controller // will generate a HelmChart object in the same namespace as the HelmRepository. type HelmChartTemplate struct { // Name of the Helm chart, as made available by the referenced Helm repository. // +required Name string ` json : \"name\"` // Version semver expression, defaults to latest when omitted. // +optional Version string ` json : \"version,omitempty\"` // The name and namespace of the source HelmRepository the chart is available at. // +required SourceRef CrossNamespaceObjectReference ` json : \"sourceRef\"` // Interval at which to check the Helm repository for chart updates. // Defaults to 'HelmReleaseSpec.Interval'. // +optional Interval *metav1.Duration ` json : \"interval,omitempty\"` } // Install holds the configuration for Helm install actions. type Install struct { // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm install action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a // Helm install has been performed. // +optional DisableWait bool ` json : \"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm install action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm install action from // validating rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool ` json : \"disableOpenAPIValidation,omitempty\"` // Replace tells the Helm install action to re-use the 'ReleaseName', but // only if that name is a deleted release which remains in the history. // +optional Replace bool ` json : \"replace,omitempty\"` // SkipCRDs tells the Helm install action to not install any CRDs. By default, // CRDs are installed if not already present. // +optional SkipCRDs bool ` json : \"skipCRDs,omitempty\"` } // Upgrade holds the configuration for Helm upgrade actions. type Upgrade struct { // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm upgrade action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // MaxRetries is the number of retries that should be attempted on failures before // bailing. Defaults to '0', a negative integer equals to unlimited retries. // +optional MaxRetries int ` json : \"maxRetries,omitempty\"` // DisableWait disables the waiting for resources to be ready after a // Helm upgrade has been performed. // +optional DisableWait bool ` json : \"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm upgrade action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm upgrade action from // validating rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool ` json : \"disableOpenAPIValidation,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool ` json : \"force,omitempty\"` // PreserveValues will make Helm reuse the last release's values and merge // in overrides from 'Values'. Setting this flag makes the HelmRelease // non-declarative. // +optional PreserveValues bool ` json : \"preserveValues,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // upgrade action when it fails. // +optional CleanupOnFail bool ` json : \"cleanupOnFail,omitempty\"` } // Test holds the configuration for Helm test actions. type Test struct { // Enable enables Helm test actions for this release after an // Helm install or upgrade action has been performed. // +optional Enable bool ` json : \"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation // during the performance of a Helm test action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` } // Rollback holds the configuration for Helm rollback actions. type Rollback struct { // Enable enables Helm rollback actions for this release after an // Helm install or upgrade action failure. // +optional Enable bool ` json : \"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm rollback action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a // Helm rollback has been performed. // +optional DisableWait bool ` json : \"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // Recreate performs pod restarts for the resource if applicable. // +optional Recreate bool ` json : \"recreate,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool ` json : \"force,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // rollback action when it fails. // +optional CleanupOnFail bool ` json : \"cleanupOnFail,omitempty\"` } // Uninstall holds the configuration for Helm uninstall actions. type Uninstall struct { // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm uninstall action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout *metav1.Duration ` json : \"timeout,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool ` json : \"disableHooks,omitempty\"` // KeepHistory tells Helm to remove all associated resources and mark the release // as deleted, but retain the release history. // +optional KeepHistory bool ` json : \"keepHistory,omitempty\" ` } Reference types: // CrossNamespaceObjectReference contains enough information to let you locate the // typed referenced object at cluster level. type CrossNamespaceObjectReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent. // +kubebuilder:validation:Enum=HelmRepository // +required Kind string `json:\"kind,omitempty\"` // Name of the referent. // +required Name string `json:\"name\"` // Namespace of the referent. // +optional Namespace string `json:\"namespace,omitempty\"` } // ValuesReference contains a reference to a resource containing Helm values, // and optionally the key they can be found at. type ValuesReference struct { // Kind of the values referent, valid values are ('Secret', 'ConfigMap'). // +kubebuilder:validation:Enum=Secret;ConfigMap // +required Kind string `json:\"kind\"` // Name of the values referent. Should reside in the same namespace as the // referring resource. // +required Name string `json:\"name\"` // ValuesKey is the key in the referent the values can be found at. // Defaults to 'values.yaml'. // +optional ValuesKey string `json:\"valuesKey,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that the HelmRelease has been successfully reconciled. ReadyCondition string = \"Ready\" // InstalledCondition represents the fact that the HelmRelease has been successfully installed. InstalledCondition string = \"Installed\" // UpgradedCondition represents the fact that the HelmRelease has been successfully upgraded. UpgradedCondition string = \"Upgraded\" // TestedCondition represents the fact that the HelmRelease has been successfully tested. TestedCondition string = \"Tested\" // RolledBackCondition represents the fact that the HelmRelease has been successfully rolled back. RolledBackCondition string = \"RolledBack\" // UninstalledCondition represents the fact that the HelmRelease has been successfully uninstalled. UninstalledCondition string = \"Uninstalled\" ) Status condition reasons: const ( // ReconciliationSucceededReason represents the fact that the reconciliation of the release has succeeded. ReconciliationSucceededReason string = \"ReconciliationSucceeded\" // ReconciliationFailedReason represents the fact that the reconciliation of the release has failed. ReconciliationFailedReason string = \"ReconciliationFailed\" // InstallSucceededReason represents the fact that the Helm install for the release succeeded. InstallSucceededReason string = \"InstallSucceeded\" // InstallFailedReason represents the fact that the Helm install for the release failed. InstallFailedReason string = \"InstallFailed\" // UpgradeSucceededReason represents the fact that the Helm upgrade for the release succeed. UpgradeSucceededReason string = \"UpgradeSucceeded\" // UpgradeFailedReason represents the fact that the Helm upgrade for the release failed. UpgradeFailedReason string = \"UpgradeFailed\" // TestFailedReason represents the fact that the Helm test for the release failed. TestSucceededReason string = \"TestSucceeded\" // TestFailedReason represents the fact that the Helm test for the release failed. TestFailedReason string = \"TestFailed\" // RollbackSucceededReason represents the fact that the Helm rollback for the release succeeded. RollbackSucceededReason string = \"RollbackSucceeded\" // RollbackFailedReason represents the fact that the Helm test for the release failed. RollbackFailedReason string = \"RollbackFailed\" // UninstallSucceededReason represents the fact that the Helm uninstall for the release succeeded. UninstallSucceededReason string = \"UninstallSucceeded\" // UninstallFailedReason represents the fact that the Helm uninstall for the release failed. UninstallFailedReason string = \"UninstallFailed\" // ArtifactFailedReason represents the fact that the artifact download for the release failed. ArtifactFailedReason string = \"ArtifactFailed\" // InitFailedReason represents the fact that the initialization of the Helm configuration failed. InitFailedReason string = \"InitFailed\" // ProgressingReason represents the fact that the reconciliation for the resource is underway. ProgressingReason string = \"Progressing\" // DependencyNotReadyReason represents the fact that the one of the dependencies is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // SuspendedReason represents the fact that the reconciliation of the HelmRelease is suspended. SuspendedReason string = \"Suspended\" )","title":"Specification"},{"location":"components/helm/helmreleases/#source-reference","text":"The HelmRelease spec.chart.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a new release. Supported source types: HelmRepository","title":"Source reference"},{"location":"components/helm/helmreleases/#reconciliation","text":"The HelmRelease spec.interval tells the reconciler at which interval to reconcile the release. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The reconcilation can be suspended by setting spec.susped to true . The reconciler can be told to reconcile the HelmRelease outside of the specified interval by annotating the object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the specified schedule. ReconcileAtAnnotation string = \"fluxcd.io/reconcileAt\" ) On-demand execution example: kubectl annotate --overwrite helmrelease/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \"","title":"Reconciliation"},{"location":"components/helm/helmreleases/#helmrelease-dependencies","text":"When applying a HelmRelease , you may need to make sure other releases exist before the release is reconciled. For example, because your chart relies on the presence of a Custom Resource Definition installed by another HelmRelease . With spec.dependsOn you can specify that the execution of a HelmRelease follows another. When you add dependsOn entries to a HelmRelease , that HelmRelease is reconciled only after all of its dependencies are ready. The readiness state of a HelmRelease is determined by its last apply status condition. Assuming two HelmRelease resources: backend - contains the backend of the application frontend - contains the frontend of the application and relies on the backend apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : backend spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m test : enable : true rollback : enable : true values : service : grpcService : backend resources : requests : cpu : 100m memory : 64Mi --- apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : frontend spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m dependsOn : - backend test : enable : true rollback : enable : true values : backend : http://backend-podinfo:9898/echo resources : requests : cpu : 100m memory : 64Mi Note that circular dependencies between HelmRelease resources must be avoided, otherwise the interdependent HelmRelease resources will never be reconciled.","title":"HelmRelease dependencies"},{"location":"components/helm/helmreleases/#enabling-helm-rollback-actions","text":"From time to time an Helm upgrade made by the helm-controller may fail, automatically recovering from this via a Helm rollback action is possible by enabling rollbacks for the HelmRelease . apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m rollback : enable : true values : resources : requests : cpu : 100m memory : 64Mi At present, rollbacks are only supported for failed upgrades. Rollback support for other failed actions (i.e. tests) is in the scope of the controller but awaits a proper design.","title":"Enabling Helm rollback actions"},{"location":"components/helm/helmreleases/#enabling-helm-test-actions","text":"To make the controller run the Helm tests available for your chart after a successful Helm install or upgrade, spec.test.enable should be set to true . apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m test : enable : true values : resources : requests : cpu : 100m memory : 64Mi At present, failed tests do not mark the HelmRelease as not Ready . Making this configurable is in the scope of the controller but awaits a proper design, as well as running them on a schedule or for other actions than a successful Helm install or upgrade.","title":"Enabling Helm test actions"},{"location":"components/helm/helmreleases/#status","text":"When the controller completes a reconciliation, it reports the result in the status sub-resource. A successful reconciliation sets the Ready condition to true : status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm installation succeeded reason : InstallSucceeded status : \"True\" type : Install - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2 You can wait for the helm-controller to complete a reconciliation with: kubectl wait helmrelease/podinfo --for = condition = ready A failed reconciliation sets the Ready condition to false : status : conditions : - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Upgrade - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : release reconciliation failed reason : ReconciliationFailed status : \"False\" type : Ready failures : 1 lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 3","title":"Status"},{"location":"components/kustomize/api/","text":"Kustomize API reference Packages: kustomize.toolkit.fluxcd.io/v1alpha1 kustomize.toolkit.fluxcd.io/v1alpha1 Package v1alpha1 contains API Schema definitions for the kustomize v1alpha1 API group Resource Types: Kustomization Kustomization Kustomization is the Schema for the kustomizations API. Field Description apiVersion string kustomize.toolkit.fluxcd.io/v1alpha1 kind string Kustomization metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec KustomizationSpec dependsOn []string (Optional) A list of kustomizations that must be ready before this kustomization can be applied. interval Kubernetes meta/v1.Duration The interval at which to apply the kustomization. path string Path to the directory containing the kustomization file. prune bool Enables garbage collection. healthChecks []WorkloadReference (Optional) A list of workloads (Deployments, DaemonSets and StatefulSets) to be included in the health assessment. serviceAccount ServiceAccount (Optional) The Kubernetes service account used for applying the kustomization. sourceRef CrossNamespaceObjectReference Reference of the source where the kustomization file is. suspend bool (Optional) This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false. timeout Kubernetes meta/v1.Duration (Optional) Timeout for validation, apply and health checking operations. Defaults to \u2018Interval\u2019 duration. validation string (Optional) Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be \u2018client\u2019 (local dry-run) or \u2018server\u2019 (APIServer dry-run). status KustomizationStatus Condition ( Appears on: KustomizationStatus ) Condition contains condition information for a kustomization. Field Description type string Type of the condition, currently (\u2018Ready\u2019). status Kubernetes core/v1.ConditionStatus Status of the condition, one of (\u2018True\u2019, \u2018False\u2019, \u2018Unknown\u2019). lastTransitionTime Kubernetes meta/v1.Time LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. CrossNamespaceObjectReference ( Appears on: KustomizationSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent KustomizationSpec ( Appears on: Kustomization ) KustomizationSpec defines the desired state of a kustomization. Field Description dependsOn []string (Optional) A list of kustomizations that must be ready before this kustomization can be applied. interval Kubernetes meta/v1.Duration The interval at which to apply the kustomization. path string Path to the directory containing the kustomization file. prune bool Enables garbage collection. healthChecks []WorkloadReference (Optional) A list of workloads (Deployments, DaemonSets and StatefulSets) to be included in the health assessment. serviceAccount ServiceAccount (Optional) The Kubernetes service account used for applying the kustomization. sourceRef CrossNamespaceObjectReference Reference of the source where the kustomization file is. suspend bool (Optional) This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false. timeout Kubernetes meta/v1.Duration (Optional) Timeout for validation, apply and health checking operations. Defaults to \u2018Interval\u2019 duration. validation string (Optional) Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be \u2018client\u2019 (local dry-run) or \u2018server\u2019 (APIServer dry-run). KustomizationStatus ( Appears on: Kustomization ) KustomizationStatus defines the observed state of a kustomization. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last reconciled generation. conditions []Condition (Optional) lastAppliedRevision string (Optional) The last successfully applied revision. The revision format for Git sources is / . lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. snapshot Snapshot (Optional) The last successfully applied revision metadata. ServiceAccount ( Appears on: KustomizationSpec ) ServiceAccount defines a reference to a Kubernetes service account. Field Description name string Name is the name of the service account being referenced. namespace string Namespace is the namespace of the service account being referenced. Snapshot ( Appears on: KustomizationStatus ) Snapshot holds the metadata of the Kubernetes objects generated for a source revision Field Description revision string The source revision. entries []SnapshotEntry A list of Kubernetes kinds grouped by namespace. SnapshotEntry ( Appears on: Snapshot ) Snapshot holds the metadata of namespaced Kubernetes objects Field Description namespace string (Optional) The namespace of this entry. kinds map[string]string The list of Kubernetes kinds. Unsortable ( [][]string alias) WorkloadReference ( Appears on: KustomizationSpec ) WorkloadReference defines a reference to a Deployment, DaemonSet or StatefulSet. Field Description kind string Kind is the type of resource being referenced. name string Name is the name of resource being referenced. namespace string Namespace is the namespace of resource being referenced. This page was automatically generated with gen-crd-api-reference-docs","title":"Kustomize API Reference"},{"location":"components/kustomize/controller/","text":"Kustomize Controller \u00b6 The kustomize-controller is a Kubernetes operator, specialized in running continuous delivery pipelines for infrastructure and workloads defined with Kubernetes manifests and assembled with Kustomize. Features: Reconciles the cluster state from multiple sources (provided by source-controller) Generates manifests with Kustomize (from plain Kubernetes yamls or Kustomize overlays) Validates manifests against Kubernetes API Impersonates service accounts (multi-tenancy RBAC) Health assessment of the deployed workloads Runs pipelines in a specific order (depends-on relationship) Prunes objects removed from source (garbage collection) Reports cluster state changes (alerting provided by notification-controller) Links: Source code fluxcd/kustomize-controller Specification docs","title":"Overview"},{"location":"components/kustomize/controller/#kustomize-controller","text":"The kustomize-controller is a Kubernetes operator, specialized in running continuous delivery pipelines for infrastructure and workloads defined with Kubernetes manifests and assembled with Kustomize. Features: Reconciles the cluster state from multiple sources (provided by source-controller) Generates manifests with Kustomize (from plain Kubernetes yamls or Kustomize overlays) Validates manifests against Kubernetes API Impersonates service accounts (multi-tenancy RBAC) Health assessment of the deployed workloads Runs pipelines in a specific order (depends-on relationship) Prunes objects removed from source (garbage collection) Reports cluster state changes (alerting provided by notification-controller) Links: Source code fluxcd/kustomize-controller Specification docs","title":"Kustomize Controller"},{"location":"components/kustomize/kustomization/","text":"Kustomization \u00b6 The Kustomization API defines a pipeline for fetching, building, testing and applying Kubernetes manifests. Specification \u00b6 A kustomization object defines the source of Kubernetes manifests by referencing an object managed by source-controller , the path to the kustomization file within that source, and the interval at which the kustomize build output is applied on the cluster. type KustomizationSpec struct { // A list of kustomization that must be ready before this // kustomization can be applied. // +optional DependsOn [] string `json:\"dependsOn,omitempty\"` // The interval at which to apply the kustomization. // +required Interval metav1 . Duration `json:\"interval\"` // Path to the directory containing the kustomization file. // +kubebuilder:validation:Pattern=\"^\\\\./\" // +required Path string `json:\"path\"` // Enables garbage collection. // +required Prune bool `json:\"prune\"` // A list of workloads (Deployments, DaemonSets and StatefulSets) // to be included in the health assessment. // +optional HealthChecks [] WorkloadReference `json:\"healthChecks,omitempty\"` // The Kubernetes service account used for applying the kustomization. // +optional ServiceAccount * ServiceAccount `json:\"serviceAccount,omitempty\"` // Reference of the source where the kustomization file is. // +required SourceRef CrossNamespaceObjectReference `json:\"sourceRef\"` // This flag tells the controller to suspend subsequent kustomize executions, // it does not apply to already started executions. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // Timeout for validation, apply and health checking operations. // Defaults to 'Interval' duration. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Validate the Kubernetes objects before applying them on the cluster. // The validation strategy can be 'client' (local dry-run) or 'server' (APIServer dry-run). // +kubebuilder:validation:Enum=client;server // +optional Validation string `json:\"validation,omitempty\"` } The status sub-resource describes the result of the last kustomization execution: type KustomizationStatus struct { // ObservedGeneration is the last reconciled generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // +optional Conditions [] Condition `json:\"conditions,omitempty\"` // The last successfully applied revision. // The revision format for Git sources is <branch|tag>/<commit-sha>. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // The last successfully applied revision metadata. // +optional Snapshot * Snapshot `json:\"snapshot\"` } Status condition types: const ( // ReadyCondition represents the fact that a given kustomization has passed // validation and was successfully applied on the cluster. ReadyCondition string = \"Ready\" ) Status condition reasons: const ( // ApplySucceededReason represents the fact that the kustomization apply succeeded. ApplySucceededReason string = \"ApplySucceeded\" // ApplyFailedReason represents the fact that the kustomization apply failed. ApplyFailedReason string = \"ApplyFailed\" // ArtifactFailedReason represents the fact that the artifact download failed. ArtifactFailedReason string = \"ArtifactFailed\" // BuildFailedReason represents the fact that the kustomize build command failed. BuildFailedReason string = \"BuildFailed\" // DependencyNotReady represents the fact that the one of the dependencies is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // HealthCheckFailedReason represents the fact that the one of the health check failed. HealthCheckFailedReason string = \"HealthCheckFailed\" // InitializedReason represents the fact that a given resource has been initialized. InitializedReason string = \"Initialized\" // ProgressingReason represents the fact that a kustomization reconciliation // is underway. ProgressingReason string = \"Progressing\" // PruneFailedReason represents the fact that the kustomization pruning failed. PruneFailedReason string = \"PruneFailed\" // SuspendedReason represents the fact that the kustomization execution is suspended. SuspendedReason string = \"Suspended\" // ValidationFailedReason represents the fact that the dry-run apply failed. ValidationFailedReason string = \"ValidationFailed\" ) Source reference \u00b6 The kustomization spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a kustomize build and apply. Source supported types: GitRepository Note that the source should contain the kustomization.yaml and all the Kubernetes manifests and configuration files referenced in the kustomization.yaml. If your repository contains only plain manifests, then you should enable kustomization.yaml generation. Generate kustomization.yaml \u00b6 If your repository contains plain Kubernetes manifests, the kustomization.yaml file is automatically generated for all the Kubernetes manifests in the spec.path and sub-directories. If the spec.prune is enable, the controller generates a label transformer to enable garbage collection . Reconciliation \u00b6 The kustomization spec.interval tells the controller at which interval to fetch the Kubernetes manifest for the source, build the kustomization and apply it on the cluster. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The kustomization execution can be suspended by setting spec.susped to true . The controller can be told to reconcile the kustomization outside of the specified interval by annotating the kustomization object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the defined schedule. ReconcileAtAnnotation string = \"fluxcd.io/reconcileAt\" ) On-demand execution example: kubectl annotate --overwrite kustomization/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \" Garbage collection \u00b6 To enable garbage collection, set spec.prune to true . Garbage collection means that the Kubernetes objects that were previously applied on the cluster but are missing from the current source revision, are removed from cluster automatically. Garbage collection is also performed when a Kustomization object is deleted, triggering a removal of all Kubernetes objects previously applied on the cluster. Health assessment \u00b6 A kustomization can contain a series of health checks used to determine the rollout status of the deployed workloads. A health check entry can reference one of the following Kubernetes types: Deployment, DaemonSet or StatefulSet. Assuming the kustomization source contains a Kubernetes Deployment named backend , a health check can be defined as follows: apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - kind : Deployment name : backend namespace : dev timeout : 2m After applying the kustomize build output, the controller verifies if the rollout completed successfully. If the deployment was successful, the kustomization ready condition is marked as true , if the rollout failed, or if it takes more than the specified timeout to complete, then the kustomization ready condition is set to false . If the deployment becomes healthy on the next execution, then the kustomization is marked as ready. Kustomization dependencies \u00b6 When applying a kustomization, you may need to make sure other resources exist before the workloads defined in your kustomization are deployed. For example, a namespace must exist before applying resources to it. With spec.dependsOn you can specify that the execution of a kustomization follows another. When you add dependsOn entries to a kustomization, that kustomization is applied only after all of its dependencies are ready. The readiness state of a kustomization is determined by its last apply status condition. Assuming two kustomizations: * common - contains a namespace and service accounts definitions * backend - contains the workloads to be deployed in that namespace You can instruct the controller to apply the common kustomization before backend : apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : common spec : interval : 5m path : \"./webapp/common/\" prune : true sourceRef : kind : GitRepository name : webapp --- apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : dependsOn : - common interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When combined with health assessment, a kustomization will run after all its dependencies health checks are passing. For example, a service mesh proxy injector should be running before deploying applications inside the mesh. apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : istio spec : interval : 5m path : \"./profiles/default/\" sourceRef : kind : GitRepository name : istio healthChecks : - kind : Deployment name : istiod namespace : istio-system timeout : 2m --- apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : dependsOn : - common - istio interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp Note that circular dependencies between kustomizations must be avoided, otherwise the interdependent kustomizations will never be applied on the cluster. Role-based access control \u00b6 By default, a kustomization apply runs under the cluster admin account and can create, modify, delete cluster level objects (namespaces, CRDs, etc) and namespeced objects (deployments, ingresses, etc). For certain kustomizations a cluster admin may wish to control what types of Kubernetes objects can be reconciled and under which namespaces. To restrict a kustomization, one can assign a service account under which the reconciliation is performed. Assuming you want to restrict a group of kustomizations to a single namespace, you can create an account with a role binding that grants access only to that namespace: apiVersion : v1 kind : Namespace metadata : name : webapp --- apiVersion : v1 kind : ServiceAccount metadata : name : webapp-reconciler namespace : webapp --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : webapp-reconciler namespace : webapp rules : - apiGroups : [ '*' ] resources : [ '*' ] verbs : [ '*' ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : webapp-reconciler namespace : webapp roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : webapp-reconciler subjects : - kind : ServiceAccount name : webapp-reconciler namespace : webapp Note that the namespace, RBAC and service account manifests should be placed in a Git source and applied with a kustomization. The kustomizations that are running under that service account should depend-on the one that contains the account. Create a kustomization that prevents altering the cluster state outside of the webapp namespace: apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : dependsOn : - common serviceAccount : name : webapp-reconciler namespace : webapp interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When the controller reconciles the frontend-webapp kustomization, it will impersonate the webapp-reconciler account. If the kustomization contains cluster level objects like CRDs or objects belonging to a different namespace, the reconciliation will fail since the account it runs under has no permissions to alter objects outside of the webapp namespace. Status \u00b6 When the controller completes a kustomization apply, reports the result in the status sub-resource. A successful reconciliation sets the ready condition to true and updates the revision field: status : conditions : - lastTransitionTime : \"2020-04-23T19:28:48Z\" message : kustomization was successfully applied reason : ApplySucceeded status : \"True\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 You can wait for the kustomize controller to complete a reconciliation with: kubectl wait kustomization/backend --for = condition = ready The controller logs the Kubernetes objects: { \"level\" : \"info\" , \"ts\" : 1587195448.071468 , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"Kustomization applied in 1.436096591s\" , \"kustomization\" : \"default/backend\" , \"output\" : { \"service/backend\" : \"created\" , \"deployment.apps/backend\" : \"created\" , \"horizontalpodautoscaler.autoscaling/backend\" : \"created\" } } A failed reconciliation sets the ready condition to false : status : conditions : - lastTransitionTime : \"2020-04-23T19:29:48Z\" message : 'server-side validation failed' reason : ValidationFailed status : \"False\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/7c500d302e38e7e4a3f327343a8a5c21acaaeb87 Note that the last applied revision is updated only on a successful reconciliation. When a reconciliation fails, the controller logs the error: { \"level\" : \"error\" , \"ts\" : 1587195448.071468 , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"server-side validation failed\" , \"kustomization\" : \"default/backend\" , \"error\" : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" }","title":"Kustomization CRD"},{"location":"components/kustomize/kustomization/#kustomization","text":"The Kustomization API defines a pipeline for fetching, building, testing and applying Kubernetes manifests.","title":"Kustomization"},{"location":"components/kustomize/kustomization/#specification","text":"A kustomization object defines the source of Kubernetes manifests by referencing an object managed by source-controller , the path to the kustomization file within that source, and the interval at which the kustomize build output is applied on the cluster. type KustomizationSpec struct { // A list of kustomization that must be ready before this // kustomization can be applied. // +optional DependsOn [] string `json:\"dependsOn,omitempty\"` // The interval at which to apply the kustomization. // +required Interval metav1 . Duration `json:\"interval\"` // Path to the directory containing the kustomization file. // +kubebuilder:validation:Pattern=\"^\\\\./\" // +required Path string `json:\"path\"` // Enables garbage collection. // +required Prune bool `json:\"prune\"` // A list of workloads (Deployments, DaemonSets and StatefulSets) // to be included in the health assessment. // +optional HealthChecks [] WorkloadReference `json:\"healthChecks,omitempty\"` // The Kubernetes service account used for applying the kustomization. // +optional ServiceAccount * ServiceAccount `json:\"serviceAccount,omitempty\"` // Reference of the source where the kustomization file is. // +required SourceRef CrossNamespaceObjectReference `json:\"sourceRef\"` // This flag tells the controller to suspend subsequent kustomize executions, // it does not apply to already started executions. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // Timeout for validation, apply and health checking operations. // Defaults to 'Interval' duration. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Validate the Kubernetes objects before applying them on the cluster. // The validation strategy can be 'client' (local dry-run) or 'server' (APIServer dry-run). // +kubebuilder:validation:Enum=client;server // +optional Validation string `json:\"validation,omitempty\"` } The status sub-resource describes the result of the last kustomization execution: type KustomizationStatus struct { // ObservedGeneration is the last reconciled generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // +optional Conditions [] Condition `json:\"conditions,omitempty\"` // The last successfully applied revision. // The revision format for Git sources is <branch|tag>/<commit-sha>. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // The last successfully applied revision metadata. // +optional Snapshot * Snapshot `json:\"snapshot\"` } Status condition types: const ( // ReadyCondition represents the fact that a given kustomization has passed // validation and was successfully applied on the cluster. ReadyCondition string = \"Ready\" ) Status condition reasons: const ( // ApplySucceededReason represents the fact that the kustomization apply succeeded. ApplySucceededReason string = \"ApplySucceeded\" // ApplyFailedReason represents the fact that the kustomization apply failed. ApplyFailedReason string = \"ApplyFailed\" // ArtifactFailedReason represents the fact that the artifact download failed. ArtifactFailedReason string = \"ArtifactFailed\" // BuildFailedReason represents the fact that the kustomize build command failed. BuildFailedReason string = \"BuildFailed\" // DependencyNotReady represents the fact that the one of the dependencies is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // HealthCheckFailedReason represents the fact that the one of the health check failed. HealthCheckFailedReason string = \"HealthCheckFailed\" // InitializedReason represents the fact that a given resource has been initialized. InitializedReason string = \"Initialized\" // ProgressingReason represents the fact that a kustomization reconciliation // is underway. ProgressingReason string = \"Progressing\" // PruneFailedReason represents the fact that the kustomization pruning failed. PruneFailedReason string = \"PruneFailed\" // SuspendedReason represents the fact that the kustomization execution is suspended. SuspendedReason string = \"Suspended\" // ValidationFailedReason represents the fact that the dry-run apply failed. ValidationFailedReason string = \"ValidationFailed\" )","title":"Specification"},{"location":"components/kustomize/kustomization/#source-reference","text":"The kustomization spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a kustomize build and apply. Source supported types: GitRepository Note that the source should contain the kustomization.yaml and all the Kubernetes manifests and configuration files referenced in the kustomization.yaml. If your repository contains only plain manifests, then you should enable kustomization.yaml generation.","title":"Source reference"},{"location":"components/kustomize/kustomization/#generate-kustomizationyaml","text":"If your repository contains plain Kubernetes manifests, the kustomization.yaml file is automatically generated for all the Kubernetes manifests in the spec.path and sub-directories. If the spec.prune is enable, the controller generates a label transformer to enable garbage collection .","title":"Generate kustomization.yaml"},{"location":"components/kustomize/kustomization/#reconciliation","text":"The kustomization spec.interval tells the controller at which interval to fetch the Kubernetes manifest for the source, build the kustomization and apply it on the cluster. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The kustomization execution can be suspended by setting spec.susped to true . The controller can be told to reconcile the kustomization outside of the specified interval by annotating the kustomization object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the defined schedule. ReconcileAtAnnotation string = \"fluxcd.io/reconcileAt\" ) On-demand execution example: kubectl annotate --overwrite kustomization/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \"","title":"Reconciliation"},{"location":"components/kustomize/kustomization/#garbage-collection","text":"To enable garbage collection, set spec.prune to true . Garbage collection means that the Kubernetes objects that were previously applied on the cluster but are missing from the current source revision, are removed from cluster automatically. Garbage collection is also performed when a Kustomization object is deleted, triggering a removal of all Kubernetes objects previously applied on the cluster.","title":"Garbage collection"},{"location":"components/kustomize/kustomization/#health-assessment","text":"A kustomization can contain a series of health checks used to determine the rollout status of the deployed workloads. A health check entry can reference one of the following Kubernetes types: Deployment, DaemonSet or StatefulSet. Assuming the kustomization source contains a Kubernetes Deployment named backend , a health check can be defined as follows: apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - kind : Deployment name : backend namespace : dev timeout : 2m After applying the kustomize build output, the controller verifies if the rollout completed successfully. If the deployment was successful, the kustomization ready condition is marked as true , if the rollout failed, or if it takes more than the specified timeout to complete, then the kustomization ready condition is set to false . If the deployment becomes healthy on the next execution, then the kustomization is marked as ready.","title":"Health assessment"},{"location":"components/kustomize/kustomization/#kustomization-dependencies","text":"When applying a kustomization, you may need to make sure other resources exist before the workloads defined in your kustomization are deployed. For example, a namespace must exist before applying resources to it. With spec.dependsOn you can specify that the execution of a kustomization follows another. When you add dependsOn entries to a kustomization, that kustomization is applied only after all of its dependencies are ready. The readiness state of a kustomization is determined by its last apply status condition. Assuming two kustomizations: * common - contains a namespace and service accounts definitions * backend - contains the workloads to be deployed in that namespace You can instruct the controller to apply the common kustomization before backend : apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : common spec : interval : 5m path : \"./webapp/common/\" prune : true sourceRef : kind : GitRepository name : webapp --- apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : dependsOn : - common interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When combined with health assessment, a kustomization will run after all its dependencies health checks are passing. For example, a service mesh proxy injector should be running before deploying applications inside the mesh. apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : istio spec : interval : 5m path : \"./profiles/default/\" sourceRef : kind : GitRepository name : istio healthChecks : - kind : Deployment name : istiod namespace : istio-system timeout : 2m --- apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : dependsOn : - common - istio interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp Note that circular dependencies between kustomizations must be avoided, otherwise the interdependent kustomizations will never be applied on the cluster.","title":"Kustomization dependencies"},{"location":"components/kustomize/kustomization/#role-based-access-control","text":"By default, a kustomization apply runs under the cluster admin account and can create, modify, delete cluster level objects (namespaces, CRDs, etc) and namespeced objects (deployments, ingresses, etc). For certain kustomizations a cluster admin may wish to control what types of Kubernetes objects can be reconciled and under which namespaces. To restrict a kustomization, one can assign a service account under which the reconciliation is performed. Assuming you want to restrict a group of kustomizations to a single namespace, you can create an account with a role binding that grants access only to that namespace: apiVersion : v1 kind : Namespace metadata : name : webapp --- apiVersion : v1 kind : ServiceAccount metadata : name : webapp-reconciler namespace : webapp --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : webapp-reconciler namespace : webapp rules : - apiGroups : [ '*' ] resources : [ '*' ] verbs : [ '*' ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : webapp-reconciler namespace : webapp roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : webapp-reconciler subjects : - kind : ServiceAccount name : webapp-reconciler namespace : webapp Note that the namespace, RBAC and service account manifests should be placed in a Git source and applied with a kustomization. The kustomizations that are running under that service account should depend-on the one that contains the account. Create a kustomization that prevents altering the cluster state outside of the webapp namespace: apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : backend spec : dependsOn : - common serviceAccount : name : webapp-reconciler namespace : webapp interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When the controller reconciles the frontend-webapp kustomization, it will impersonate the webapp-reconciler account. If the kustomization contains cluster level objects like CRDs or objects belonging to a different namespace, the reconciliation will fail since the account it runs under has no permissions to alter objects outside of the webapp namespace.","title":"Role-based access control"},{"location":"components/kustomize/kustomization/#status","text":"When the controller completes a kustomization apply, reports the result in the status sub-resource. A successful reconciliation sets the ready condition to true and updates the revision field: status : conditions : - lastTransitionTime : \"2020-04-23T19:28:48Z\" message : kustomization was successfully applied reason : ApplySucceeded status : \"True\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 You can wait for the kustomize controller to complete a reconciliation with: kubectl wait kustomization/backend --for = condition = ready The controller logs the Kubernetes objects: { \"level\" : \"info\" , \"ts\" : 1587195448.071468 , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"Kustomization applied in 1.436096591s\" , \"kustomization\" : \"default/backend\" , \"output\" : { \"service/backend\" : \"created\" , \"deployment.apps/backend\" : \"created\" , \"horizontalpodautoscaler.autoscaling/backend\" : \"created\" } } A failed reconciliation sets the ready condition to false : status : conditions : - lastTransitionTime : \"2020-04-23T19:29:48Z\" message : 'server-side validation failed' reason : ValidationFailed status : \"False\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/7c500d302e38e7e4a3f327343a8a5c21acaaeb87 Note that the last applied revision is updated only on a successful reconciliation. When a reconciliation fails, the controller logs the error: { \"level\" : \"error\" , \"ts\" : 1587195448.071468 , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"server-side validation failed\" , \"kustomization\" : \"default/backend\" , \"error\" : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" }","title":"Status"},{"location":"components/notification/alert/","text":"Alert \u00b6 The Alert API defines how events are filtered by severity and involved object, and what provider to use for dispatching. Specification \u00b6 Spec: type AlertSpec struct { // Send events using this provider // +required ProviderRef corev1 . LocalObjectReference `json:\"providerRef\"` // Filter events based on severity, defaults to ('info'). // +kubebuilder:validation:Enum=info;error // +optional EventSeverity string `json:\"eventSeverity,omitempty\"` // Filter events based on the involved objects // +required EventSources [] CrossNamespaceObjectReference `json:\"eventSources\"` // This flag tells the controller to suspend subsequent events dispatching. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" ) Example \u00b6 apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : webapp namespace : gitops-system spec : providerRef : name : on-call-slack eventSeverity : info eventSources : - kind : GitRepository name : webapp - kind : Kustomization name : webapp-backend - kind : Kustomization name : webapp-frontend The event severity can be set to info or error . To target all resources of a particular kind in a namespace, you can use the * wildcard: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : all-kustomizations namespace : gitops-system spec : providerRef : name : dev-msteams eventSeverity : error eventSources : - kind : Kustomization namespace : gitops-system name : '*' suspend : false If you don't specify an event source namespace, the alert namespace will be used.","title":"Alert CRD"},{"location":"components/notification/alert/#alert","text":"The Alert API defines how events are filtered by severity and involved object, and what provider to use for dispatching.","title":"Alert"},{"location":"components/notification/alert/#specification","text":"Spec: type AlertSpec struct { // Send events using this provider // +required ProviderRef corev1 . LocalObjectReference `json:\"providerRef\"` // Filter events based on severity, defaults to ('info'). // +kubebuilder:validation:Enum=info;error // +optional EventSeverity string `json:\"eventSeverity,omitempty\"` // Filter events based on the involved objects // +required EventSources [] CrossNamespaceObjectReference `json:\"eventSources\"` // This flag tells the controller to suspend subsequent events dispatching. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" )","title":"Specification"},{"location":"components/notification/alert/#example","text":"apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : webapp namespace : gitops-system spec : providerRef : name : on-call-slack eventSeverity : info eventSources : - kind : GitRepository name : webapp - kind : Kustomization name : webapp-backend - kind : Kustomization name : webapp-frontend The event severity can be set to info or error . To target all resources of a particular kind in a namespace, you can use the * wildcard: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : all-kustomizations namespace : gitops-system spec : providerRef : name : dev-msteams eventSeverity : error eventSources : - kind : Kustomization namespace : gitops-system name : '*' suspend : false If you don't specify an event source namespace, the alert namespace will be used.","title":"Example"},{"location":"components/notification/api/","text":"Kustomize API reference Packages: notification.toolkit.fluxcd.io/v1alpha1 notification.toolkit.fluxcd.io/v1alpha1 Package v1alpha1 contains API Schema definitions for the notification v1alpha1 API group Resource Types: Alert Provider Receiver Alert Alert is the Schema for the alerts API Field Description apiVersion string notification.toolkit.fluxcd.io/v1alpha1 kind string Alert metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec AlertSpec providerRef Kubernetes core/v1.LocalObjectReference Send events using this provider eventSeverity string (Optional) Filter events based on severity, defaults to (\u2018info\u2019). eventSources []CrossNamespaceObjectReference Filter events based on the involved objects suspend bool (Optional) This flag tells the controller to suspend subsequent events dispatching. Defaults to false. status AlertStatus Provider Provider is the Schema for the providers API Field Description apiVersion string notification.toolkit.fluxcd.io/v1alpha1 kind string Provider metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ProviderSpec type string Type of provider channel string (Optional) Alert channel for this provider username string (Optional) Bot username for this provider address string (Optional) HTTP(S) webhook address of this provider secretRef Kubernetes core/v1.LocalObjectReference (Optional) Secret reference containing the provider webhook URL status ProviderStatus Receiver Receiver is the Schema for the receivers API Field Description apiVersion string notification.toolkit.fluxcd.io/v1alpha1 kind string Receiver metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ReceiverSpec type string Type of webhook sender, used to determine the validation procedure and payload deserialization. events []string (Optional) A list of events to handle, e.g. \u2018push\u2019 for GitHub or \u2018Push Hook\u2019 for GitLab. resources []CrossNamespaceObjectReference A list of resources to be notified about changes. secretRef Kubernetes core/v1.LocalObjectReference Secret reference containing the token used to validate the payload authenticity suspend bool (Optional) This flag tells the controller to suspend subsequent events handling. Defaults to false. status ReceiverStatus AlertSpec ( Appears on: Alert ) AlertSpec defines an alerting rule for events involving a list of objects Field Description providerRef Kubernetes core/v1.LocalObjectReference Send events using this provider eventSeverity string (Optional) Filter events based on severity, defaults to (\u2018info\u2019). eventSources []CrossNamespaceObjectReference Filter events based on the involved objects suspend bool (Optional) This flag tells the controller to suspend subsequent events dispatching. Defaults to false. AlertStatus ( Appears on: Alert ) AlertStatus defines the observed state of Alert Field Description conditions []Condition (Optional) Condition ( Appears on: AlertStatus , ProviderStatus , ReceiverStatus ) Condition contains condition information for a notification object. Field Description type string Type of the condition, currently (\u2018Ready\u2019). status Kubernetes core/v1.ConditionStatus Status of the condition, one of (\u2018True\u2019, \u2018False\u2019, \u2018Unknown\u2019). lastTransitionTime Kubernetes meta/v1.Time LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. CrossNamespaceObjectReference ( Appears on: AlertSpec , ReceiverSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent ProviderSpec ( Appears on: Provider ) ProviderSpec defines the desired state of Provider Field Description type string Type of provider channel string (Optional) Alert channel for this provider username string (Optional) Bot username for this provider address string (Optional) HTTP(S) webhook address of this provider secretRef Kubernetes core/v1.LocalObjectReference (Optional) Secret reference containing the provider webhook URL ProviderStatus ( Appears on: Provider ) ProviderStatus defines the observed state of Provider Field Description conditions []Condition (Optional) ReceiverSpec ( Appears on: Receiver ) ReceiverSpec defines the desired state of Receiver Field Description type string Type of webhook sender, used to determine the validation procedure and payload deserialization. events []string (Optional) A list of events to handle, e.g. \u2018push\u2019 for GitHub or \u2018Push Hook\u2019 for GitLab. resources []CrossNamespaceObjectReference A list of resources to be notified about changes. secretRef Kubernetes core/v1.LocalObjectReference Secret reference containing the token used to validate the payload authenticity suspend bool (Optional) This flag tells the controller to suspend subsequent events handling. Defaults to false. ReceiverStatus ( Appears on: Receiver ) ReceiverStatus defines the observed state of Receiver Field Description conditions []Condition (Optional) url string (Optional) Generated webhook URL in the format of \u2018/hook/sha256sum(token+name+namespace)\u2019. This page was automatically generated with gen-crd-api-reference-docs","title":"Notification API Reference"},{"location":"components/notification/controller/","text":"Notification Controller \u00b6 The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events. The controller handles events coming from external systems (GitHub, GitLab, Bitbucket, Harbour, Jenkins, etc) and notifies the GitOps toolkit controllers about source changes. The controller handles events emitted by the GitOps toolkit controllers (source, kustomize, helm) and dispatches them to external systems (Slack, Microsoft Teams, Discord, Rocker) based on event severity and involved objects. Links: Source code fluxcd/notification-controller Specification docs","title":"Overview"},{"location":"components/notification/controller/#notification-controller","text":"The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events. The controller handles events coming from external systems (GitHub, GitLab, Bitbucket, Harbour, Jenkins, etc) and notifies the GitOps toolkit controllers about source changes. The controller handles events emitted by the GitOps toolkit controllers (source, kustomize, helm) and dispatches them to external systems (Slack, Microsoft Teams, Discord, Rocker) based on event severity and involved objects. Links: Source code fluxcd/notification-controller Specification docs","title":"Notification Controller"},{"location":"components/notification/event/","text":"Event \u00b6 The Event API defines what information a report of an event issued by a controller should contain. Specification \u00b6 Spec: type Event struct { // The object that this event is about. // +required InvolvedObject corev1 . ObjectReference `json:\"involvedObject\"` // Severity type of this event (info, error) // +required Severity string `json:\"severity\"` // The time at which this event was recorded. // +required Timestamp metav1 . Time `json:\"timestamp\"` // A human-readable description of this event. // Maximum length 39,000 characters // +required Message string `json:\"message\"` // A machine understandable string that gives the reason // for the transition into the object's current status. // +required Reason string `json:\"reason\"` // Metadata of this event, e.g. apply change set. // +optional Metadata map [ string ] string `json:\"metadata,omitempty\"` // Name of the controller that emitted this event, e.g. `source-controller`. // +required ReportingController string `json:\"reportingController\"` // ID of the controller instance, e.g. `source-controller-xyzf`. // +optional ReportingInstance string `json:\"reportingInstance,omitempty\"` } Event severity: const ( EventSeverityInfo string = \"info\" EventSeverityError string = \"error\" ) Controller implementations can use the fluxcd/pkg/recorder package to push events to notification-controller API.","title":"Event"},{"location":"components/notification/event/#event","text":"The Event API defines what information a report of an event issued by a controller should contain.","title":"Event"},{"location":"components/notification/event/#specification","text":"Spec: type Event struct { // The object that this event is about. // +required InvolvedObject corev1 . ObjectReference `json:\"involvedObject\"` // Severity type of this event (info, error) // +required Severity string `json:\"severity\"` // The time at which this event was recorded. // +required Timestamp metav1 . Time `json:\"timestamp\"` // A human-readable description of this event. // Maximum length 39,000 characters // +required Message string `json:\"message\"` // A machine understandable string that gives the reason // for the transition into the object's current status. // +required Reason string `json:\"reason\"` // Metadata of this event, e.g. apply change set. // +optional Metadata map [ string ] string `json:\"metadata,omitempty\"` // Name of the controller that emitted this event, e.g. `source-controller`. // +required ReportingController string `json:\"reportingController\"` // ID of the controller instance, e.g. `source-controller-xyzf`. // +optional ReportingInstance string `json:\"reportingInstance,omitempty\"` } Event severity: const ( EventSeverityInfo string = \"info\" EventSeverityError string = \"error\" ) Controller implementations can use the fluxcd/pkg/recorder package to push events to notification-controller API.","title":"Specification"},{"location":"components/notification/provider/","text":"Provider \u00b6 The Provider API defines how events are encoded and the webhook address where they are dispatched. Specification \u00b6 Spec: type ProviderSpec struct { // Type of provider // +kubebuilder:validation:Enum=slack;discord;msteams;rocket;generic // +required Type string `json:\"type\"` // Alert channel for this provider // +optional Channel string `json:\"channel,omitempty\"` // Bot username for this provider // +optional Username string `json:\"username,omitempty\"` // HTTP(S) webhook address of this provider // +optional Address string `json:\"address,omitempty\"` // Secret reference containing the provider webhook URL // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Notification providers: Slack Discord Microsoft Teams Rocket Generic webhook Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" ) Example \u00b6 apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : slack namespace : gitops-system spec : type : slack channel : general # webhook address (ignored if secretRef is specified) address : https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK # secret containing the webhook address (optional) secretRef : name : webhook-url Webhook URL secret: kubectl -n gitops-system create secret generic webhook-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field. The provider type can be: slack , msteams , rocket , discord or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address.","title":"Provider CRD"},{"location":"components/notification/provider/#provider","text":"The Provider API defines how events are encoded and the webhook address where they are dispatched.","title":"Provider"},{"location":"components/notification/provider/#specification","text":"Spec: type ProviderSpec struct { // Type of provider // +kubebuilder:validation:Enum=slack;discord;msteams;rocket;generic // +required Type string `json:\"type\"` // Alert channel for this provider // +optional Channel string `json:\"channel,omitempty\"` // Bot username for this provider // +optional Username string `json:\"username,omitempty\"` // HTTP(S) webhook address of this provider // +optional Address string `json:\"address,omitempty\"` // Secret reference containing the provider webhook URL // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Notification providers: Slack Discord Microsoft Teams Rocket Generic webhook Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" )","title":"Specification"},{"location":"components/notification/provider/#example","text":"apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : slack namespace : gitops-system spec : type : slack channel : general # webhook address (ignored if secretRef is specified) address : https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK # secret containing the webhook address (optional) secretRef : name : webhook-url Webhook URL secret: kubectl -n gitops-system create secret generic webhook-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field. The provider type can be: slack , msteams , rocket , discord or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address.","title":"Example"},{"location":"components/notification/receiver/","text":"Receiver \u00b6 The Receiver API defines a webhook receiver that triggers reconciliation for a group of resources. Specification \u00b6 type ReceiverSpec struct { // Type of webhook sender, used to determine // the validation procedure and payload deserialization. // +kubebuilder:validation:Enum=generic;github;gitlab;harbor // +required Type string `json:\"type\"` // A list of events to handle, // e.g. 'push' for GitHub or 'Push Hook' for GitLab. // +optional Events [] string `json:\"events\"` // A list of resources to be notified about changes. // +required Resources [] CrossNamespaceObjectReference `json:\"resources\"` // Secret reference containing the token used // to validate the payload authenticity // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // This flag tells the controller to suspend subsequent events handling. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Receiver types: const ( GenericReceiver string = \"generic\" GitHubReceiver string = \"github\" GitLabReceiver string = \"gitlab\" BitbucketReceiver string = \"bitbucket\" HarborReceiver string = \"harbor\" ) Status \u00b6 type ReceiverStatus struct { // Generated webhook URL in the format // of '/hook/sha256sum(token+name+namespace)'. // +required URL string `json:\"url\"` } Example \u00b6 Generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN GitHub receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : github-receiver namespace : gitops-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp Note that you have to set the generated token as the GitHub webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. GitLab receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : gitlab-receiver namespace : gitops-system spec : type : gitlab events : - \"Push Hook\" - \"Tag Push Hook\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp-frontend - kind : GitRepository name : webapp-backend Note that you have to configure the GitLab webhook with the generated token. The controller uses the X-Gitlab-Token HTTP header to verify that the request is legitimate. Bitbucket server receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : bitbucket-receiver namespace : gitops-system spec : type : bitbucket events : - \"repo:refs_changed\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note that you have to set the generated token as the Bitbucket server webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. Harbor receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : harbor-receiver namespace : gitops-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : webapp Note that you have to set the generated token as the Harbor webhook authentication header. The controller uses the Authentication HTTP header to verify that the request is legitimate. Generic receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : generic-receiver namespace : gitops-system spec : type : generic secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp When the receiver type is set to generic , the controller will not perform token validation nor event filtering.","title":"Receiver CRD"},{"location":"components/notification/receiver/#receiver","text":"The Receiver API defines a webhook receiver that triggers reconciliation for a group of resources.","title":"Receiver"},{"location":"components/notification/receiver/#specification","text":"type ReceiverSpec struct { // Type of webhook sender, used to determine // the validation procedure and payload deserialization. // +kubebuilder:validation:Enum=generic;github;gitlab;harbor // +required Type string `json:\"type\"` // A list of events to handle, // e.g. 'push' for GitHub or 'Push Hook' for GitLab. // +optional Events [] string `json:\"events\"` // A list of resources to be notified about changes. // +required Resources [] CrossNamespaceObjectReference `json:\"resources\"` // Secret reference containing the token used // to validate the payload authenticity // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // This flag tells the controller to suspend subsequent events handling. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Receiver types: const ( GenericReceiver string = \"generic\" GitHubReceiver string = \"github\" GitLabReceiver string = \"gitlab\" BitbucketReceiver string = \"bitbucket\" HarborReceiver string = \"harbor\" )","title":"Specification"},{"location":"components/notification/receiver/#status","text":"type ReceiverStatus struct { // Generated webhook URL in the format // of '/hook/sha256sum(token+name+namespace)'. // +required URL string `json:\"url\"` }","title":"Status"},{"location":"components/notification/receiver/#example","text":"Generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN GitHub receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : github-receiver namespace : gitops-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp Note that you have to set the generated token as the GitHub webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. GitLab receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : gitlab-receiver namespace : gitops-system spec : type : gitlab events : - \"Push Hook\" - \"Tag Push Hook\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp-frontend - kind : GitRepository name : webapp-backend Note that you have to configure the GitLab webhook with the generated token. The controller uses the X-Gitlab-Token HTTP header to verify that the request is legitimate. Bitbucket server receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : bitbucket-receiver namespace : gitops-system spec : type : bitbucket events : - \"repo:refs_changed\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note that you have to set the generated token as the Bitbucket server webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. Harbor receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : harbor-receiver namespace : gitops-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : webapp Note that you have to set the generated token as the Harbor webhook authentication header. The controller uses the Authentication HTTP header to verify that the request is legitimate. Generic receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : generic-receiver namespace : gitops-system spec : type : generic secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp When the receiver type is set to generic , the controller will not perform token validation nor event filtering.","title":"Example"},{"location":"components/source/api/","text":"Source API reference Packages: source.toolkit.fluxcd.io/v1alpha1 source.toolkit.fluxcd.io/v1alpha1 Package v1alpha1 contains API Schema definitions for the source v1alpha1 API group Resource Types: GitRepository HelmChart HelmRepository GitRepository GitRepository is the Schema for the gitrepositories API Field Description apiVersion string source.toolkit.fluxcd.io/v1alpha1 kind string GitRepository metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec GitRepositorySpec url string The repository URL, can be a HTTP or SSH address. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields. interval Kubernetes meta/v1.Duration The interval at which to check for repository updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for remote git operations like cloning, default to 20s. ref GitRepositoryRef (Optional) The git reference to checkout and monitor for changes, defaults to master branch. verify GitRepositoryVerification (Optional) Verify OpenPGP signature for the commit that HEAD points to. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. status GitRepositoryStatus HelmChart HelmChart is the Schema for the helmcharts API Field Description apiVersion string source.toolkit.fluxcd.io/v1alpha1 kind string HelmChart metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmChartSpec name string The name of the Helm chart, as made available by the referenced Helm repository. version string (Optional) The chart version semver expression, defaults to latest when omitted. helmRepositoryRef Kubernetes core/v1.LocalObjectReference The name of the HelmRepository the chart is available at. interval Kubernetes meta/v1.Duration The interval at which to check the Helm repository for updates. status HelmChartStatus HelmRepository HelmRepository is the Schema for the helmrepositories API Field Description apiVersion string source.toolkit.fluxcd.io/v1alpha1 kind string HelmRepository metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmRepositorySpec url string The Helm repository URL, a valid URL contains at least a protocol and host. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain caFile, keyFile and caCert fields. interval Kubernetes meta/v1.Duration The interval at which to check the upstream for updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout of index downloading, defaults to 60s. status HelmRepositoryStatus Artifact ( Appears on: GitRepositoryStatus , HelmChartStatus , HelmRepositoryStatus ) Artifact represents the output of a source synchronisation Field Description path string Path is the local file path of this artifact. url string URL is the HTTP address of this artifact. revision string (Optional) Revision is a human readable identifier traceable in the origin source system. It can be a commit sha, git tag, a helm index timestamp, a helm chart version, a checksum, etc. lastUpdateTime Kubernetes meta/v1.Time LastUpdateTime is the timestamp corresponding to the last update of this artifact. GitRepositoryRef ( Appears on: GitRepositorySpec ) GitRepositoryRef defines the git ref used for pull and checkout operations. Field Description branch string (Optional) The git branch to checkout, defaults to master. tag string (Optional) The git tag to checkout, takes precedence over branch. semver string (Optional) The git tag semver expression, takes precedence over tag. commit string (Optional) The git commit sha to checkout, if specified tag filters will be ignored. GitRepositorySpec ( Appears on: GitRepository ) GitRepositorySpec defines the desired state of a Git repository. Field Description url string The repository URL, can be a HTTP or SSH address. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields. interval Kubernetes meta/v1.Duration The interval at which to check for repository updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for remote git operations like cloning, default to 20s. ref GitRepositoryRef (Optional) The git reference to checkout and monitor for changes, defaults to master branch. verify GitRepositoryVerification (Optional) Verify OpenPGP signature for the commit that HEAD points to. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. GitRepositoryStatus ( Appears on: GitRepository ) GitRepositoryStatus defines the observed state of a Git repository. Field Description conditions []SourceCondition (Optional) url string (Optional) URL is the download link for the artifact output of the last repository sync. artifact Artifact (Optional) Artifact represents the output of the last successful repository sync. GitRepositoryVerification ( Appears on: GitRepositorySpec ) GitRepositoryVerification defines the OpenPGP signature verification process. Field Description mode string Mode describes what git object should be verified, currently (\u2018head\u2019). secretRef Kubernetes core/v1.LocalObjectReference The secret name containing the public keys of all trusted git authors. HelmChartSpec ( Appears on: HelmChart ) HelmChartSpec defines the desired state of a Helm chart. Field Description name string The name of the Helm chart, as made available by the referenced Helm repository. version string (Optional) The chart version semver expression, defaults to latest when omitted. helmRepositoryRef Kubernetes core/v1.LocalObjectReference The name of the HelmRepository the chart is available at. interval Kubernetes meta/v1.Duration The interval at which to check the Helm repository for updates. HelmChartStatus ( Appears on: HelmChart ) HelmChartStatus defines the observed state of the HelmChart. Field Description conditions []SourceCondition (Optional) url string (Optional) URL is the download link for the last chart pulled. artifact Artifact (Optional) Artifact represents the output of the last successful chart sync. HelmRepositorySpec ( Appears on: HelmRepository ) HelmRepositorySpec defines the reference to a Helm repository. Field Description url string The Helm repository URL, a valid URL contains at least a protocol and host. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain caFile, keyFile and caCert fields. interval Kubernetes meta/v1.Duration The interval at which to check the upstream for updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout of index downloading, defaults to 60s. HelmRepositoryStatus ( Appears on: HelmRepository ) HelmRepositoryStatus defines the observed state of the HelmRepository. Field Description conditions []SourceCondition (Optional) url string (Optional) URL is the download link for the last index fetched. artifact Artifact (Optional) Artifact represents the output of the last successful repository sync. Source Source interface must be supported by all API types. SourceCondition ( Appears on: GitRepositoryStatus , HelmChartStatus , HelmRepositoryStatus ) SourceCondition contains condition information for a source. Field Description type string Type of the condition, currently (\u2018Ready\u2019). status Kubernetes core/v1.ConditionStatus Status of the condition, one of (\u2018True\u2019, \u2018False\u2019, \u2018Unknown\u2019). lastTransitionTime Kubernetes meta/v1.Time LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. This page was automatically generated with gen-crd-api-reference-docs","title":"Source API Reference"},{"location":"components/source/controller/","text":"Source Controller \u00b6 The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller. Features: Validate source definitions Authenticate to sources (SSH, user/password, API token) Validate source authenticity (PGP) Detect source changes based on update policies (semver) Fetch resources on-demand and on-a-schedule Package the fetched resources into a well-known format (tar.gz, yaml) Make the artifacts addressable by their source identifier (sha, version, ts) Make the artifacts available in-cluster to interested 3rd parties Notify interested 3rd parties of source changes and availability (status conditions, events, hooks) Links: Source code fluxcd/source-controller Specification docs","title":"Overview"},{"location":"components/source/controller/#source-controller","text":"The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller. Features: Validate source definitions Authenticate to sources (SSH, user/password, API token) Validate source authenticity (PGP) Detect source changes based on update policies (semver) Fetch resources on-demand and on-a-schedule Package the fetched resources into a well-known format (tar.gz, yaml) Make the artifacts addressable by their source identifier (sha, version, ts) Make the artifacts available in-cluster to interested 3rd parties Notify interested 3rd parties of source changes and availability (status conditions, events, hooks) Links: Source code fluxcd/source-controller Specification docs","title":"Source Controller"},{"location":"components/source/gitrepositories/","text":"Git Repositories \u00b6 The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive . Specification \u00b6 Git repository: // GitRepositorySpec gives the specification for fetching a Git repository as // a source. type GitRepositorySpec struct { // The repository URL, can be a HTTP or SSH address. // +kubebuilder:validation:Pattern=\"^(http|https|ssh)://\" URL string `json:\"url\"` // The secret name containing the Git credentials. // For HTTPS repositories the secret must contain username and password // fields. // For SSH repositories the secret must contain identity, identity.pub and // known_hosts fields. // +optional SecretRef * v1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for repository updates. Interval metav1 . Duration `json:\"interval\"` // The timeout for remote git operations like cloning, default to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // The git reference to checkout and monitor for changes, defaults to // master branch. // +optional Reference * GitRepositoryRef `json:\"ref,omitempty\"` // Verify OpenPGP signature for the commit that HEAD points to. // +optional Verification * GitRepositoryVerification `json:\"verify,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore // format (which is the same as .gitignore). If not provided, a default will // be used, consult the documentation for your version to find out what those // are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Git repository reference: // GitRepositoryRef defines the git ref used for pull and checkout operations. type GitRepositoryRef struct { // The git branch to checkout, defaults to master. // +optional Branch string `json:\"branch,omitempty\"` // The git tag to checkout, takes precedence over branch. // +optional Tag string `json:\"tag,omitempty\"` // The git tag semver expression, takes precedence over tag. // +optional SemVer string `json:\"semver,omitempty\"` // The git commit sha to checkout, if specified tag filters will be ignored. // +optional Commit string `json:\"commit,omitempty\"` } Git repository cryptographic provenance verification: // GitRepositoryVerification defines the OpenPGP signature verification process. type GitRepositoryVerification struct { // Mode describes what git object should be verified, currently ('head'). // +kubebuilder:validation:Enum=head Mode string `json:\"mode\"` // The secret name containing the public keys of all trusted git authors. SecretRef corev1 . LocalObjectReference `json:\"secretRef\"` } Status \u00b6 // GitRepositoryStatus defines the observed state of the GitRepository. type GitRepositoryStatus struct { // +optional Conditions [] SourceCondition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last repository // sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // GitOperationSucceedReason represents the fact that the git // clone, pull and checkout operations succeeded. GitOperationSucceedReason string = \"GitOperationSucceed\" // GitOperationFailedReason represents the fact that the git // clone, pull or checkout operations failed. GitOperationFailedReason string = \"GitOperationFailed\" ) Artifact \u00b6 The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive ( <commit hash>.tar.gz ). Excluding files \u00b6 Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the repository. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 5m url : https://github.com/stefanprodan/podinfo ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list. Spec examples \u00b6 Pull the master branch of a public repository every minute: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo Pull a specific branch: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : v3.x Checkout a specific commit from a branch: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master commit : 363a6a8fe6a7f13e05d34c163b0ef02a777da20a Pull a specific tag: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : tag : 3.2.0 Pull tag based on a semver range : apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : semver : \">=3.1.0-rc.1 <3.2.0\" HTTPS authentication (requires a secret with username and password fields): apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : url : https://github.com/stefanprodan/podinfo secretRef : name : https-credentials --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> SSH authentication (requires a secret with identity and known_hosts fields): apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : url : ssh://git@github.com/stefanprodan/podinfo secretRef : name : ssh-credentials --- apiVersion : v1 kind : Secret metadata : name : ssh-credentials namespace : default type : Opaque data : identity : <BASE64> identity.pub : <BASE64> known_hosts : <BASE64> Note: that the SSH address does not support SCP syntax. The URL format is ssh://user@host:port/org/repository . Example of generating the SSH credentials secret: ssh-keygen -q -N \"\" -f ./identity ssh-keyscan github.com > ./known_hosts kubectl create secret generic ssh-credentials \\ --from-file = ./identity \\ --from-file = ./identity.pub \\ --from-file = ./known_hosts Verify the OpenPGP signature for the commit that master branch HEAD points to: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master verify : mode : head secretRef : name : pgp-public-keys --- apiVersion : v1 kind : Secret metadata : name : pgp-public-keys namespace : default type : Opaque data : author1.asc : <BASE64> author2.asc : <BASE64> Example of generating the PGP public keys secret: gpg --export --armor 3CB12BA185C47B67 > author1.asc gpg --export --armor 6A7436E8790F8689 > author2.asc kubectl create secret generic pgp-public-keys \\ --from-file = author1.asc \\ --from-file = author2.asc Status examples \u00b6 Successful sync: status : artifact : lastUpdateTime : \"2020-04-07T06:59:23Z\" path : /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz revision : master/363a6a8fe6a7f13e05d34c163b0ef02a777da20a url : http://<host>/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz conditions : - lastTransitionTime : \"2020-04-07T06:59:23Z\" message : 'Git repoistory artifacts are available at: /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz' reason : GitOperationSucceed status : \"True\" type : Ready url : http://<host>/gitrepository/default/podinfo/latest.tar.gz Failed authentication: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'git clone error ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain' reason : AuthenticationFailed status : \"False\" type : Ready Failed PGP signature verification: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'PGP signature of {Stefan Prodan 2020-04-04 13:36:58 +0300 +0300} can not be verified' reason : VerificationFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait gitrepository/podinfo --for = condition = ready --timeout = 1m","title":"GitRepository CRD"},{"location":"components/source/gitrepositories/#git-repositories","text":"The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive .","title":"Git Repositories"},{"location":"components/source/gitrepositories/#specification","text":"Git repository: // GitRepositorySpec gives the specification for fetching a Git repository as // a source. type GitRepositorySpec struct { // The repository URL, can be a HTTP or SSH address. // +kubebuilder:validation:Pattern=\"^(http|https|ssh)://\" URL string `json:\"url\"` // The secret name containing the Git credentials. // For HTTPS repositories the secret must contain username and password // fields. // For SSH repositories the secret must contain identity, identity.pub and // known_hosts fields. // +optional SecretRef * v1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for repository updates. Interval metav1 . Duration `json:\"interval\"` // The timeout for remote git operations like cloning, default to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // The git reference to checkout and monitor for changes, defaults to // master branch. // +optional Reference * GitRepositoryRef `json:\"ref,omitempty\"` // Verify OpenPGP signature for the commit that HEAD points to. // +optional Verification * GitRepositoryVerification `json:\"verify,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore // format (which is the same as .gitignore). If not provided, a default will // be used, consult the documentation for your version to find out what those // are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Git repository reference: // GitRepositoryRef defines the git ref used for pull and checkout operations. type GitRepositoryRef struct { // The git branch to checkout, defaults to master. // +optional Branch string `json:\"branch,omitempty\"` // The git tag to checkout, takes precedence over branch. // +optional Tag string `json:\"tag,omitempty\"` // The git tag semver expression, takes precedence over tag. // +optional SemVer string `json:\"semver,omitempty\"` // The git commit sha to checkout, if specified tag filters will be ignored. // +optional Commit string `json:\"commit,omitempty\"` } Git repository cryptographic provenance verification: // GitRepositoryVerification defines the OpenPGP signature verification process. type GitRepositoryVerification struct { // Mode describes what git object should be verified, currently ('head'). // +kubebuilder:validation:Enum=head Mode string `json:\"mode\"` // The secret name containing the public keys of all trusted git authors. SecretRef corev1 . LocalObjectReference `json:\"secretRef\"` }","title":"Specification"},{"location":"components/source/gitrepositories/#status","text":"// GitRepositoryStatus defines the observed state of the GitRepository. type GitRepositoryStatus struct { // +optional Conditions [] SourceCondition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last repository // sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/gitrepositories/#condition-reasons","text":"const ( // GitOperationSucceedReason represents the fact that the git // clone, pull and checkout operations succeeded. GitOperationSucceedReason string = \"GitOperationSucceed\" // GitOperationFailedReason represents the fact that the git // clone, pull or checkout operations failed. GitOperationFailedReason string = \"GitOperationFailed\" )","title":"Condition reasons"},{"location":"components/source/gitrepositories/#artifact","text":"The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive ( <commit hash>.tar.gz ).","title":"Artifact"},{"location":"components/source/gitrepositories/#excluding-files","text":"Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the repository. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 5m url : https://github.com/stefanprodan/podinfo ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list.","title":"Excluding files"},{"location":"components/source/gitrepositories/#spec-examples","text":"Pull the master branch of a public repository every minute: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo Pull a specific branch: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : v3.x Checkout a specific commit from a branch: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master commit : 363a6a8fe6a7f13e05d34c163b0ef02a777da20a Pull a specific tag: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : tag : 3.2.0 Pull tag based on a semver range : apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : semver : \">=3.1.0-rc.1 <3.2.0\" HTTPS authentication (requires a secret with username and password fields): apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : url : https://github.com/stefanprodan/podinfo secretRef : name : https-credentials --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> SSH authentication (requires a secret with identity and known_hosts fields): apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : url : ssh://git@github.com/stefanprodan/podinfo secretRef : name : ssh-credentials --- apiVersion : v1 kind : Secret metadata : name : ssh-credentials namespace : default type : Opaque data : identity : <BASE64> identity.pub : <BASE64> known_hosts : <BASE64> Note: that the SSH address does not support SCP syntax. The URL format is ssh://user@host:port/org/repository . Example of generating the SSH credentials secret: ssh-keygen -q -N \"\" -f ./identity ssh-keyscan github.com > ./known_hosts kubectl create secret generic ssh-credentials \\ --from-file = ./identity \\ --from-file = ./identity.pub \\ --from-file = ./known_hosts Verify the OpenPGP signature for the commit that master branch HEAD points to: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master verify : mode : head secretRef : name : pgp-public-keys --- apiVersion : v1 kind : Secret metadata : name : pgp-public-keys namespace : default type : Opaque data : author1.asc : <BASE64> author2.asc : <BASE64> Example of generating the PGP public keys secret: gpg --export --armor 3CB12BA185C47B67 > author1.asc gpg --export --armor 6A7436E8790F8689 > author2.asc kubectl create secret generic pgp-public-keys \\ --from-file = author1.asc \\ --from-file = author2.asc","title":"Spec examples"},{"location":"components/source/gitrepositories/#status-examples","text":"Successful sync: status : artifact : lastUpdateTime : \"2020-04-07T06:59:23Z\" path : /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz revision : master/363a6a8fe6a7f13e05d34c163b0ef02a777da20a url : http://<host>/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz conditions : - lastTransitionTime : \"2020-04-07T06:59:23Z\" message : 'Git repoistory artifacts are available at: /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz' reason : GitOperationSucceed status : \"True\" type : Ready url : http://<host>/gitrepository/default/podinfo/latest.tar.gz Failed authentication: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'git clone error ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain' reason : AuthenticationFailed status : \"False\" type : Ready Failed PGP signature verification: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'PGP signature of {Stefan Prodan 2020-04-04 13:36:58 +0300 +0300} can not be verified' reason : VerificationFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait gitrepository/podinfo --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/helmcharts/","text":"Helm Charts \u00b6 The HelmChart API defines a source for Helm chart artifacts coming from HelmRepository sources . The resource exposes the latest pulled chart for the defined version as an artifact. Specification \u00b6 Helm chart: // HelmChartSpec defines the desired state of a Helm chart source. type HelmChartSpec struct { // The name of the Helm chart, as made available by the referenced // Helm repository. // +required Name string `json:\"name\"` // The chart version semver expression, defaults to latest when // omitted. // +optional Version string `json:\"version,omitempty\"` // The name of the HelmRepository the chart is available at. // +required HelmRepositoryRef v1 . LocalObjectReference `json:\"helmRepositoryRef\"` // The interval at which to check the referenced HelmRepository index // for updates. // +required Interval metav1 . Duration `json:\"interval\"` } Status \u00b6 // HelmChartStatus defines the observed state of the HelmChart. type HelmChartStatus struct { // +optional Conditions [] SourceCondition `json:\"conditions,omitempty\"` // URL is the download link for the last chart fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful chart sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // ChartPullFailedReason represents the fact that the pull of the // given Helm chart failed. ChartPullFailedReason string = \"ChartPullFailed\" // ChartPullSucceededReason represents the fact that the pull of // the given Helm chart succeeded. ChartPullSucceededReason string = \"ChartPullSucceeded\" ) Spec examples \u00b6 Pull a specific chart version every five minutes: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmChart metadata : name : redis spec : name : redis version : 10.5.7 helmRepositoryRef : name : stable interval : 5m Pull the latest chart version that matches the sermver range every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmChart metadata : name : redis spec : name : redis version : ^10.0.0 helmRepositoryRef : name : stable interval : 10m Status examples \u00b6 Successful chart pull: status : url : http://<host>/helmchart/default/redis/redis-10.5.7.tgz conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm chart is available at /data/helmchart/default/redis/redis-10.5.7.tgz reason : ChartPullSucceeded status : \"True\" type : Ready Failed chart pull: status : conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : 'invalid chart URL format' reason : ChartPullFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait helmchart/redis --for = condition = ready --timeout = 1m","title":"HelmChart CRD"},{"location":"components/source/helmcharts/#helm-charts","text":"The HelmChart API defines a source for Helm chart artifacts coming from HelmRepository sources . The resource exposes the latest pulled chart for the defined version as an artifact.","title":"Helm Charts"},{"location":"components/source/helmcharts/#specification","text":"Helm chart: // HelmChartSpec defines the desired state of a Helm chart source. type HelmChartSpec struct { // The name of the Helm chart, as made available by the referenced // Helm repository. // +required Name string `json:\"name\"` // The chart version semver expression, defaults to latest when // omitted. // +optional Version string `json:\"version,omitempty\"` // The name of the HelmRepository the chart is available at. // +required HelmRepositoryRef v1 . LocalObjectReference `json:\"helmRepositoryRef\"` // The interval at which to check the referenced HelmRepository index // for updates. // +required Interval metav1 . Duration `json:\"interval\"` }","title":"Specification"},{"location":"components/source/helmcharts/#status","text":"// HelmChartStatus defines the observed state of the HelmChart. type HelmChartStatus struct { // +optional Conditions [] SourceCondition `json:\"conditions,omitempty\"` // URL is the download link for the last chart fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful chart sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/helmcharts/#condition-reasons","text":"const ( // ChartPullFailedReason represents the fact that the pull of the // given Helm chart failed. ChartPullFailedReason string = \"ChartPullFailed\" // ChartPullSucceededReason represents the fact that the pull of // the given Helm chart succeeded. ChartPullSucceededReason string = \"ChartPullSucceeded\" )","title":"Condition reasons"},{"location":"components/source/helmcharts/#spec-examples","text":"Pull a specific chart version every five minutes: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmChart metadata : name : redis spec : name : redis version : 10.5.7 helmRepositoryRef : name : stable interval : 5m Pull the latest chart version that matches the sermver range every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmChart metadata : name : redis spec : name : redis version : ^10.0.0 helmRepositoryRef : name : stable interval : 10m","title":"Spec examples"},{"location":"components/source/helmcharts/#status-examples","text":"Successful chart pull: status : url : http://<host>/helmchart/default/redis/redis-10.5.7.tgz conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm chart is available at /data/helmchart/default/redis/redis-10.5.7.tgz reason : ChartPullSucceeded status : \"True\" type : Ready Failed chart pull: status : conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : 'invalid chart URL format' reason : ChartPullFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait helmchart/redis --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/helmrepositories/","text":"Helm Repositories \u00b6 The HelmRepository API defines a source for Helm repositories. The resource exposes the latest synchronized repository index as an artifact. Specification \u00b6 Helm repository: // HelmRepositorySpec defines the reference to a Helm repository. type HelmRepositorySpec struct { // The Helm repository URL, a valid URL contains at least a // protocol and host. // +required URL string `json:\"url\"` // The name of the secret containing authentication credentials // for the Helm repository. // For HTTP/S basic auth the secret must contain username and password // fields. // For TLS the secret must contain caFile, keyFile and caCert fields. // +optional SecretRef * v1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check the upstream for updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout of index downloading, defaults to 60s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` } Status \u00b6 // HelmRepositoryStatus defines the observed state of the HelmRepository. type HelmRepositoryStatus struct { // +optional Conditions [] SourceCondition `json:\"conditions,omitempty\"` // URL is the download link for the last index fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // IndexationFailedReason represents the fact that the indexation // of the given Helm repository failed. IndexationFailedReason string = \"IndexationFailed\" // IndexationSucceededReason represents the fact that the indexation // of the given Helm repository succeeded. IndexationSucceedReason string = \"IndexationSucceed\" ) Spec examples \u00b6 Pull the index of a public Helm repository every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : stable spec : url : https://kubernetes-charts.storage.googleapis.com/ interval : 10m Pull the index of a private Helm repository every minute: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : private spec : url : https://charts.example.com secretRef : name : https-credentials interval : 1m --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> certFile : <BASE64> keyFile : <BASE64> caFile : <BASE64> Status examples \u00b6 Successful indexation: status : url : http://<host>/helmrepository/default/stable/index.yaml conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm repository index is available at /data/helmrepository/default/stable/index-21c195d78e699e4b656e2885887d019627838993.yaml reason : IndexationSucceeded status : \"True\" type : Ready Failed indexation: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : 'failed to fetch https://invalid.example.com/index.yaml : 404 Not Found' reason : IndexationFailed status : \"False\" type : Ready Invalid repository URL: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : scheme \"invalid\" not supported reason : URLInvalid status : \"False\" type : Ready Wait for ready condition: kubectl wait helmrepository/stable --for = condition = ready --timeout = 1m","title":"HelmRepository CRD"},{"location":"components/source/helmrepositories/#helm-repositories","text":"The HelmRepository API defines a source for Helm repositories. The resource exposes the latest synchronized repository index as an artifact.","title":"Helm Repositories"},{"location":"components/source/helmrepositories/#specification","text":"Helm repository: // HelmRepositorySpec defines the reference to a Helm repository. type HelmRepositorySpec struct { // The Helm repository URL, a valid URL contains at least a // protocol and host. // +required URL string `json:\"url\"` // The name of the secret containing authentication credentials // for the Helm repository. // For HTTP/S basic auth the secret must contain username and password // fields. // For TLS the secret must contain caFile, keyFile and caCert fields. // +optional SecretRef * v1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check the upstream for updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout of index downloading, defaults to 60s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` }","title":"Specification"},{"location":"components/source/helmrepositories/#status","text":"// HelmRepositoryStatus defines the observed state of the HelmRepository. type HelmRepositoryStatus struct { // +optional Conditions [] SourceCondition `json:\"conditions,omitempty\"` // URL is the download link for the last index fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/helmrepositories/#condition-reasons","text":"const ( // IndexationFailedReason represents the fact that the indexation // of the given Helm repository failed. IndexationFailedReason string = \"IndexationFailed\" // IndexationSucceededReason represents the fact that the indexation // of the given Helm repository succeeded. IndexationSucceedReason string = \"IndexationSucceed\" )","title":"Condition reasons"},{"location":"components/source/helmrepositories/#spec-examples","text":"Pull the index of a public Helm repository every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : stable spec : url : https://kubernetes-charts.storage.googleapis.com/ interval : 10m Pull the index of a private Helm repository every minute: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : private spec : url : https://charts.example.com secretRef : name : https-credentials interval : 1m --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> certFile : <BASE64> keyFile : <BASE64> caFile : <BASE64>","title":"Spec examples"},{"location":"components/source/helmrepositories/#status-examples","text":"Successful indexation: status : url : http://<host>/helmrepository/default/stable/index.yaml conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm repository index is available at /data/helmrepository/default/stable/index-21c195d78e699e4b656e2885887d019627838993.yaml reason : IndexationSucceeded status : \"True\" type : Ready Failed indexation: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : 'failed to fetch https://invalid.example.com/index.yaml : 404 Not Found' reason : IndexationFailed status : \"False\" type : Ready Invalid repository URL: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : scheme \"invalid\" not supported reason : URLInvalid status : \"False\" type : Ready Wait for ready condition: kubectl wait helmrepository/stable --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"contributing/","text":"Contributing \u00b6 The GitOps Toolkit is Apache 2.0 licensed and accepts contributions via GitHub pull requests. This document outlines some of the conventions on to make it easier to get your contribution accepted. We gratefully welcome improvements to issues and documentation as well as to code. Certificate of Origin \u00b6 By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. No action from you is required, but it's a good idea to see the DCO file for details before you start contributing code to FluxCD organization. Communications \u00b6 For realtime communications we use Slack: To join the conversation, simply join the CNCF Slack workspace and use the #flux-dev channel. To discuss ideas and specifications we use Github Discussions . For announcements we use a mailing list as well. Simply subscribe to flux-dev on cncf.io to join the conversation (there you can also add calendar invites to your Google calendar for our Flux meeting ). Understanding the GitOps Toolkit \u00b6 If you are entirely new to the GitOps Toolkit, you might want to take a look at the introductory talk and demo . This project is composed of: /f/toolkit : The GitOps Toolkit CLI /f/source-manager : Kubernetes operator for managing sources /f/kustomize-controller : Kubernetes operator for building GitOps pipelines with Kustomize /f/helm-controller : Kubernetes operator for building GitOps pipelines with Helm /f/notification-controller : Kubernetes operator for handling inbound and outbound events Understanding the code \u00b6 To get started with developing controllers, you might want to review our guide which walks you through writing a short and concise controller that watches out for source changes. How to run the test suite \u00b6 You can run the unit tests by simply doing make test Acceptance policy \u00b6 These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message (see below) all code must abide Go Code Review Comments names should abide What's in a name code must build on both Linux and Darwin, via plain go build code should have appropriate test coverage and tests should be written to work with go test In general, we will merge a PR once one maintainer has endorsed it. For substantial changes, more people may become involved, and you might get asked to resubmit the PR or divide the changes into more than one PR. Format of the Commit Message \u00b6 For the GitOps Toolkit controllers we prefer the following rules for good commit messages: Limit the subject to 50 characters and write as the continuation of the sentence \"If applied, this commit will ...\" Explain what and why in the body, if more than a trivial change; wrap it at 72 characters. The following article has some more helpful advice on documenting your work.","title":"Contributing"},{"location":"contributing/#contributing","text":"The GitOps Toolkit is Apache 2.0 licensed and accepts contributions via GitHub pull requests. This document outlines some of the conventions on to make it easier to get your contribution accepted. We gratefully welcome improvements to issues and documentation as well as to code.","title":"Contributing"},{"location":"contributing/#certificate-of-origin","text":"By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. No action from you is required, but it's a good idea to see the DCO file for details before you start contributing code to FluxCD organization.","title":"Certificate of Origin"},{"location":"contributing/#communications","text":"For realtime communications we use Slack: To join the conversation, simply join the CNCF Slack workspace and use the #flux-dev channel. To discuss ideas and specifications we use Github Discussions . For announcements we use a mailing list as well. Simply subscribe to flux-dev on cncf.io to join the conversation (there you can also add calendar invites to your Google calendar for our Flux meeting ).","title":"Communications"},{"location":"contributing/#understanding-the-gitops-toolkit","text":"If you are entirely new to the GitOps Toolkit, you might want to take a look at the introductory talk and demo . This project is composed of: /f/toolkit : The GitOps Toolkit CLI /f/source-manager : Kubernetes operator for managing sources /f/kustomize-controller : Kubernetes operator for building GitOps pipelines with Kustomize /f/helm-controller : Kubernetes operator for building GitOps pipelines with Helm /f/notification-controller : Kubernetes operator for handling inbound and outbound events","title":"Understanding the GitOps Toolkit"},{"location":"contributing/#understanding-the-code","text":"To get started with developing controllers, you might want to review our guide which walks you through writing a short and concise controller that watches out for source changes.","title":"Understanding the code"},{"location":"contributing/#how-to-run-the-test-suite","text":"You can run the unit tests by simply doing make test","title":"How to run the test suite"},{"location":"contributing/#acceptance-policy","text":"These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message (see below) all code must abide Go Code Review Comments names should abide What's in a name code must build on both Linux and Darwin, via plain go build code should have appropriate test coverage and tests should be written to work with go test In general, we will merge a PR once one maintainer has endorsed it. For substantial changes, more people may become involved, and you might get asked to resubmit the PR or divide the changes into more than one PR.","title":"Acceptance policy"},{"location":"contributing/#format-of-the-commit-message","text":"For the GitOps Toolkit controllers we prefer the following rules for good commit messages: Limit the subject to 50 characters and write as the continuation of the sentence \"If applied, this commit will ...\" Explain what and why in the body, if more than a trivial change; wrap it at 72 characters. The following article has some more helpful advice on documenting your work.","title":"Format of the Commit Message"},{"location":"dev-guides/source-watcher/","text":"Watching for source changes \u00b6 In this guide you'll be developing a Kubernetes controller with Kubebuilder that subscribes to GitRepository events and reacts to revision changes by downloading the artifact produced by source-controller . Prerequisites \u00b6 On your dev machine install the following tools: go >= 1.13 kubebuilder >= 2.3 kind >= 0.8 kubectl >= 1.18 kustomize >= 3.5 docker >= 19.03 Install the GitOps Toolkit \u00b6 Create a cluster for testing: kind create cluster --name dev Install the toolkit CLI: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash Verify that your dev machine satisfies the prerequisites with: tk check --pre Install the toolkit controllers on the dev cluster: tk install Clone the sample controller \u00b6 You'll be using stefanprodan/source-watcher as a template for developing your own controller. The source-watcher was scaffolded with kubebuilder init . Clone the source-watcher repo: git clone https://github.com/stefanprodan/source-watcher cd source-watcher Build the controller: make Run the controller \u00b6 Port forward to source-controller artifacts server: kubectl -n gitops-system port-forward svc/source-controller 8181 :80 Export the local address as SOURCE_HOST : export SOURCE_HOST = localhost:8181 Run source-watcher locally: make run Create a Git source: tk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.0 The source-watcher should log the revision: New revision detected {\"gitrepository\": \"gitops-system/test\", \"revision\": \"4.0.0/ab953493ee14c3c9800bda0251e0c507f9741408\"} Extracted tarball into /var/folders/77/3y6x_p2j2g9fspdkzjbm5_s40000gn/T/test292235827: 123 files, 29 dirs (32.603415ms) Processing files... Change the Git tag: tk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.1 The source-watcher should log the new revision: New revision detected {\"gitrepository\": \"gitops-system/test\", \"revision\": \"4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27\"} The source-controller reports the revision under GitRepository.Status.Artifact.Revision in the format: <branch|tag>/<commit> . How it works \u00b6 The GitRepositoryWatcher controller does the following: subscribes to GitRepository events detects when the Git revision changes downloads and extracts the source artifact write to stdout the extracted file names // GitRepositoryWatcher watches GitRepository objects for revision changes type GitRepositoryWatcher struct { client . Client Log logr . Logger Scheme * runtime . Scheme } // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories,verbs=get;list;watch // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories/status,verbs=get func ( r * GitRepositoryWatcher ) Reconcile ( req ctrl . Request ) ( ctrl . Result , error ) { // set timeout for the reconciliation ctx , cancel := context . WithTimeout ( context . Background (), 15 * time . Second ) defer cancel () // get source object var repository sourcev1 . GitRepository if err := r . Get ( ctx , req . NamespacedName , & repository ); err != nil { return ctrl . Result {}, client . IgnoreNotFound ( err ) } log := r . Log . WithValues ( strings . ToLower ( repository . Kind ), req . NamespacedName ) log . Info ( \"New revision detected\" , \"revision\" , repository . Status . Artifact . Revision ) // create tmp dir tmpDir , err := ioutil . TempDir ( \"\" , repository . Name ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to create temp dir, error: %w\" , err ) } defer os . RemoveAll ( tmpDir ) // download and extract artifact summary , err := r . fetchArtifact ( ctx , repository , tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to fetch artifact, error: %w\" , err ) } log . Info ( summary ) // list artifact content files , err := ioutil . ReadDir ( tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to list files, error: %w\" , err ) } // do something with the artifact content for _ , f := range files { log . Info ( \"Processing \" + f . Name ()) } return ctrl . Result {}, nil } func ( r * GitRepositoryWatcher ) SetupWithManager ( mgr ctrl . Manager ) error { return ctrl . NewControllerManagedBy ( mgr ). For ( & sourcev1 . GitRepository {}). WithEventFilter ( GitRepositoryRevisionChangePredicate {}). Complete ( r ) } To add the watcher to an existing project, copy the controller and the revision change predicate to your controllers dir: gitrepository_watcher.go gitrepository_predicate.go In your main.go init function, register the Source API schema: import sourcev1 \"github.com/fluxcd/source-controller/api/v1alpha1\" func init () { _ = clientgoscheme . AddToScheme ( scheme ) _ = sourcev1 . AddToScheme ( scheme ) // +kubebuilder:scaffold:scheme } Start the controller in the main function: func main () { if err = ( & controllers . GitRepositoryWatcher { Client : mgr . GetClient (), Log : ctrl . Log . WithName ( \"controllers\" ). WithName ( \"GitRepositoryWatcher\" ), Scheme : mgr . GetScheme (), }). SetupWithManager ( mgr ); err != nil { setupLog . Error ( err , \"unable to create controller\" , \"controller\" , \"GitRepositoryWatcher\" ) os . Exit ( 1 ) } } Note that the watcher controller depends on Kubernetes client-go >= 1.18. Your go.mod should require controller-runtime v0.6 or newer: require ( k8s . io / apimachinery v0 .18.4 k8s . io / client - go v0 .18.4 sigs . k8s . io / controller - runtime v0 .6.0 ) That's it! Happy hacking!","title":"Watching for source changes"},{"location":"dev-guides/source-watcher/#watching-for-source-changes","text":"In this guide you'll be developing a Kubernetes controller with Kubebuilder that subscribes to GitRepository events and reacts to revision changes by downloading the artifact produced by source-controller .","title":"Watching for source changes"},{"location":"dev-guides/source-watcher/#prerequisites","text":"On your dev machine install the following tools: go >= 1.13 kubebuilder >= 2.3 kind >= 0.8 kubectl >= 1.18 kustomize >= 3.5 docker >= 19.03","title":"Prerequisites"},{"location":"dev-guides/source-watcher/#install-the-gitops-toolkit","text":"Create a cluster for testing: kind create cluster --name dev Install the toolkit CLI: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash Verify that your dev machine satisfies the prerequisites with: tk check --pre Install the toolkit controllers on the dev cluster: tk install","title":"Install the GitOps Toolkit"},{"location":"dev-guides/source-watcher/#clone-the-sample-controller","text":"You'll be using stefanprodan/source-watcher as a template for developing your own controller. The source-watcher was scaffolded with kubebuilder init . Clone the source-watcher repo: git clone https://github.com/stefanprodan/source-watcher cd source-watcher Build the controller: make","title":"Clone the sample controller"},{"location":"dev-guides/source-watcher/#run-the-controller","text":"Port forward to source-controller artifacts server: kubectl -n gitops-system port-forward svc/source-controller 8181 :80 Export the local address as SOURCE_HOST : export SOURCE_HOST = localhost:8181 Run source-watcher locally: make run Create a Git source: tk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.0 The source-watcher should log the revision: New revision detected {\"gitrepository\": \"gitops-system/test\", \"revision\": \"4.0.0/ab953493ee14c3c9800bda0251e0c507f9741408\"} Extracted tarball into /var/folders/77/3y6x_p2j2g9fspdkzjbm5_s40000gn/T/test292235827: 123 files, 29 dirs (32.603415ms) Processing files... Change the Git tag: tk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.1 The source-watcher should log the new revision: New revision detected {\"gitrepository\": \"gitops-system/test\", \"revision\": \"4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27\"} The source-controller reports the revision under GitRepository.Status.Artifact.Revision in the format: <branch|tag>/<commit> .","title":"Run the controller"},{"location":"dev-guides/source-watcher/#how-it-works","text":"The GitRepositoryWatcher controller does the following: subscribes to GitRepository events detects when the Git revision changes downloads and extracts the source artifact write to stdout the extracted file names // GitRepositoryWatcher watches GitRepository objects for revision changes type GitRepositoryWatcher struct { client . Client Log logr . Logger Scheme * runtime . Scheme } // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories,verbs=get;list;watch // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories/status,verbs=get func ( r * GitRepositoryWatcher ) Reconcile ( req ctrl . Request ) ( ctrl . Result , error ) { // set timeout for the reconciliation ctx , cancel := context . WithTimeout ( context . Background (), 15 * time . Second ) defer cancel () // get source object var repository sourcev1 . GitRepository if err := r . Get ( ctx , req . NamespacedName , & repository ); err != nil { return ctrl . Result {}, client . IgnoreNotFound ( err ) } log := r . Log . WithValues ( strings . ToLower ( repository . Kind ), req . NamespacedName ) log . Info ( \"New revision detected\" , \"revision\" , repository . Status . Artifact . Revision ) // create tmp dir tmpDir , err := ioutil . TempDir ( \"\" , repository . Name ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to create temp dir, error: %w\" , err ) } defer os . RemoveAll ( tmpDir ) // download and extract artifact summary , err := r . fetchArtifact ( ctx , repository , tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to fetch artifact, error: %w\" , err ) } log . Info ( summary ) // list artifact content files , err := ioutil . ReadDir ( tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to list files, error: %w\" , err ) } // do something with the artifact content for _ , f := range files { log . Info ( \"Processing \" + f . Name ()) } return ctrl . Result {}, nil } func ( r * GitRepositoryWatcher ) SetupWithManager ( mgr ctrl . Manager ) error { return ctrl . NewControllerManagedBy ( mgr ). For ( & sourcev1 . GitRepository {}). WithEventFilter ( GitRepositoryRevisionChangePredicate {}). Complete ( r ) } To add the watcher to an existing project, copy the controller and the revision change predicate to your controllers dir: gitrepository_watcher.go gitrepository_predicate.go In your main.go init function, register the Source API schema: import sourcev1 \"github.com/fluxcd/source-controller/api/v1alpha1\" func init () { _ = clientgoscheme . AddToScheme ( scheme ) _ = sourcev1 . AddToScheme ( scheme ) // +kubebuilder:scaffold:scheme } Start the controller in the main function: func main () { if err = ( & controllers . GitRepositoryWatcher { Client : mgr . GetClient (), Log : ctrl . Log . WithName ( \"controllers\" ). WithName ( \"GitRepositoryWatcher\" ), Scheme : mgr . GetScheme (), }). SetupWithManager ( mgr ); err != nil { setupLog . Error ( err , \"unable to create controller\" , \"controller\" , \"GitRepositoryWatcher\" ) os . Exit ( 1 ) } } Note that the watcher controller depends on Kubernetes client-go >= 1.18. Your go.mod should require controller-runtime v0.6 or newer: require ( k8s . io / apimachinery v0 .18.4 k8s . io / client - go v0 .18.4 sigs . k8s . io / controller - runtime v0 .6.0 ) That's it! Happy hacking!","title":"How it works"},{"location":"faq/","text":"Frequently asked questions \u00b6 General questions \u00b6 What does the GitOps Toolkit mean for Flux? \u00b6 Flux v1 is a monolithic do-it-all operator; the GitOps Toolkit separates the functionalities into specialized controllers. Flux v2 will be a curated configuration of the GitOps Toolkit, which you can install and operate simply using the tk command. You can easily pick and choose the functionality you need and extend it to serve your own purposes. The timeline we are looking at right now is: Put Flux v1 into maintenance mode (no new features being added; bugfixes and CVEs patched only). Continue work on GitOps Toolkit roadmap . We will provide transition guides for specific user groups, e.g. users of Flux v1 in read-only mode, or of Helm Operator v1, etc. once the functionality is integrated in the GitOps Toolkit and it's deemed \"ready\". Once the use-cases of Flux v1 are covered, we will continue supporting Flux v1 for 6 months. This will be the transition period before it's considered unsupported. Why did you rewrite Flux? \u00b6 The GitOps Toolkit implements its functionality in individual controllers, which allowed us to address long-standing feature requests much more easily. By basing these controllers on modern Kubernetes tooling ( controller-runtime libraries), they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools -- and you get greatly increased observability. This gave us the opportunity to build the GitOps Toolkit with the top Flux feature requests in mind: Supporting multiple source Git repositories Operational insight through health checks, events and alerts Multi-tenancy capabilities, like applying each source repository with its own set of permissions On top of that, testing the GitOps Toolkit and understanding the codebase becomes a lot easier. What are significant new differences between Flux v1 and the GitOps Toolkit? \u00b6 Reconciliation \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Limited to a single Git repository Multiple Git repositories Declarative config via arguments in the Flux deployment GitRepository custom resource, which produces an artifact which can be reconciled by other controllers Follow HEAD of Git branches Supports Git branches, pinning on commits and tags, follow SemVer tag ranges Suspending of reconciliation by downscaling Flux deployment Reconciliation can be paused per resource by suspending the GitRepository Credentials config via Arguments and/or Secret volume mounts in the Flux pod Credentials config per GitRepository resource: SSH private key, HTTP/S username/password/token, OpenPGP public keys kustomize support \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Declarative config through .flux.yaml files in the Git repository Declarative config through a Kustomization custom resource, consuming the artifact from the GitRepository Manifests are generated via shell exec and then reconciled by fluxd Generation, server-side validation, and reconciliation is handled by a specialised kustomize-controller Reconciliation using the service account of the Flux deployment Support for service account impersonation Garbage collection needs cluster role binding for Flux to query the Kubernetes discovery API Garbage collection needs no cluster role binding or access to Kubernetes discovery API Support for custom commands and generators executed by fluxd in a POSIX shell No support for custom commands Helm integration \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Declarative config in a single Helm custom resource Declarative config through HelmRepository , HelmChart and HelmRelease custom resources Chart synchronisation embedded in the operator Extensive release configuration options, and a reconciliation interval per source Support for fixed SemVer versions from Helm repositories Support for SemVer ranges for HelmChart resources Git repository synchronisation on a global interval Planned support for charts from GitRepository sources Limited observability via the status object of the HelmRelease resource Better observability via the HelmRelease status object, Kubernetes events, and notifications Resource heavy, relatively slow Better performance Notifications, webhooks, observability \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Emits \"custom Flux events\" to a webhook endpoint Emits Kubernetes events for all custom resources part of the Toolkit RPC endpoint can be configured to a 3rd party solution like FluxCloud to be forwarded as notifications to e.g. Slack Toolkit components can be configured to POST the events to a notification-controller endpoint. Selective forwarding of POSTed events as notifications using Provider and Alert custom resources. Webhook receiver is a side-project Webhook receiver, handling a wide range of platforms, is included Unstructured logging Structured logging for all components Custom Prometheus metrics Generic / common controller-runtime Prometheus metrics How can I get involved? \u00b6 There are a variety of ways and we look forward to having you on board building the future of GitOps together: Discuss the direction of the GitOps Toolkit with us Join us in #flux-dev on the CNCF Slack Check out our contributor docs Take a look at the roadmap of the GitOps Toolkit Are there any breaking changes? \u00b6 In Flux v1 Kustomize support was implemented through .flux.yaml files in the Git repository. As indicated in the comparison table above, while this approach worked, we found it to be error-prone and hard to debug. The new Kustomization CR should make troubleshooting much easier. Unfortunately we needed to drop the support for custom commands as running arbitrary shell scripts in-cluster poses serious security concerns. Helm users: we redesigned the HelmRelease API and the automation will work quite differently, so upgrading to HelmRelease v2 will require a little work from you, but you will gain more flexibility, better observability and performance. Is the GitOps Toolkit related to the GitOps Engine? \u00b6 In an announcement in August 2019, the expectation was set that the Flux project would integrate the GitOps Engine, then being factored out of ArgoCD. Since the result would be backward-incompatible, it would require a major version bump: Flux v2. After experimentation and considerable thought, we (the maintainers) have found a path to Flux v2 that we think better serves our vision of GitOps: the GitOps Toolkit. In consequence, we do not now plan to integrate GitOps Engine into Flux.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq/#general-questions","text":"","title":"General questions"},{"location":"faq/#what-does-the-gitops-toolkit-mean-for-flux","text":"Flux v1 is a monolithic do-it-all operator; the GitOps Toolkit separates the functionalities into specialized controllers. Flux v2 will be a curated configuration of the GitOps Toolkit, which you can install and operate simply using the tk command. You can easily pick and choose the functionality you need and extend it to serve your own purposes. The timeline we are looking at right now is: Put Flux v1 into maintenance mode (no new features being added; bugfixes and CVEs patched only). Continue work on GitOps Toolkit roadmap . We will provide transition guides for specific user groups, e.g. users of Flux v1 in read-only mode, or of Helm Operator v1, etc. once the functionality is integrated in the GitOps Toolkit and it's deemed \"ready\". Once the use-cases of Flux v1 are covered, we will continue supporting Flux v1 for 6 months. This will be the transition period before it's considered unsupported.","title":"What does the GitOps Toolkit mean for Flux?"},{"location":"faq/#why-did-you-rewrite-flux","text":"The GitOps Toolkit implements its functionality in individual controllers, which allowed us to address long-standing feature requests much more easily. By basing these controllers on modern Kubernetes tooling ( controller-runtime libraries), they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools -- and you get greatly increased observability. This gave us the opportunity to build the GitOps Toolkit with the top Flux feature requests in mind: Supporting multiple source Git repositories Operational insight through health checks, events and alerts Multi-tenancy capabilities, like applying each source repository with its own set of permissions On top of that, testing the GitOps Toolkit and understanding the codebase becomes a lot easier.","title":"Why did you rewrite Flux?"},{"location":"faq/#what-are-significant-new-differences-between-flux-v1-and-the-gitops-toolkit","text":"","title":"What are significant new differences between Flux v1 and the GitOps Toolkit?"},{"location":"faq/#reconciliation","text":"Flux v1 Toolkit component driven \"Flux v2\" Limited to a single Git repository Multiple Git repositories Declarative config via arguments in the Flux deployment GitRepository custom resource, which produces an artifact which can be reconciled by other controllers Follow HEAD of Git branches Supports Git branches, pinning on commits and tags, follow SemVer tag ranges Suspending of reconciliation by downscaling Flux deployment Reconciliation can be paused per resource by suspending the GitRepository Credentials config via Arguments and/or Secret volume mounts in the Flux pod Credentials config per GitRepository resource: SSH private key, HTTP/S username/password/token, OpenPGP public keys","title":"Reconciliation"},{"location":"faq/#kustomize-support","text":"Flux v1 Toolkit component driven \"Flux v2\" Declarative config through .flux.yaml files in the Git repository Declarative config through a Kustomization custom resource, consuming the artifact from the GitRepository Manifests are generated via shell exec and then reconciled by fluxd Generation, server-side validation, and reconciliation is handled by a specialised kustomize-controller Reconciliation using the service account of the Flux deployment Support for service account impersonation Garbage collection needs cluster role binding for Flux to query the Kubernetes discovery API Garbage collection needs no cluster role binding or access to Kubernetes discovery API Support for custom commands and generators executed by fluxd in a POSIX shell No support for custom commands","title":"kustomize support"},{"location":"faq/#helm-integration","text":"Flux v1 Toolkit component driven \"Flux v2\" Declarative config in a single Helm custom resource Declarative config through HelmRepository , HelmChart and HelmRelease custom resources Chart synchronisation embedded in the operator Extensive release configuration options, and a reconciliation interval per source Support for fixed SemVer versions from Helm repositories Support for SemVer ranges for HelmChart resources Git repository synchronisation on a global interval Planned support for charts from GitRepository sources Limited observability via the status object of the HelmRelease resource Better observability via the HelmRelease status object, Kubernetes events, and notifications Resource heavy, relatively slow Better performance","title":"Helm integration"},{"location":"faq/#notifications-webhooks-observability","text":"Flux v1 Toolkit component driven \"Flux v2\" Emits \"custom Flux events\" to a webhook endpoint Emits Kubernetes events for all custom resources part of the Toolkit RPC endpoint can be configured to a 3rd party solution like FluxCloud to be forwarded as notifications to e.g. Slack Toolkit components can be configured to POST the events to a notification-controller endpoint. Selective forwarding of POSTed events as notifications using Provider and Alert custom resources. Webhook receiver is a side-project Webhook receiver, handling a wide range of platforms, is included Unstructured logging Structured logging for all components Custom Prometheus metrics Generic / common controller-runtime Prometheus metrics","title":"Notifications, webhooks, observability"},{"location":"faq/#how-can-i-get-involved","text":"There are a variety of ways and we look forward to having you on board building the future of GitOps together: Discuss the direction of the GitOps Toolkit with us Join us in #flux-dev on the CNCF Slack Check out our contributor docs Take a look at the roadmap of the GitOps Toolkit","title":"How can I get involved?"},{"location":"faq/#are-there-any-breaking-changes","text":"In Flux v1 Kustomize support was implemented through .flux.yaml files in the Git repository. As indicated in the comparison table above, while this approach worked, we found it to be error-prone and hard to debug. The new Kustomization CR should make troubleshooting much easier. Unfortunately we needed to drop the support for custom commands as running arbitrary shell scripts in-cluster poses serious security concerns. Helm users: we redesigned the HelmRelease API and the automation will work quite differently, so upgrading to HelmRelease v2 will require a little work from you, but you will gain more flexibility, better observability and performance.","title":"Are there any breaking changes?"},{"location":"faq/#is-the-gitops-toolkit-related-to-the-gitops-engine","text":"In an announcement in August 2019, the expectation was set that the Flux project would integrate the GitOps Engine, then being factored out of ArgoCD. Since the result would be backward-incompatible, it would require a major version bump: Flux v2. After experimentation and considerable thought, we (the maintainers) have found a path to Flux v2 that we think better serves our vision of GitOps: the GitOps Toolkit. In consequence, we do not now plan to integrate GitOps Engine into Flux.","title":"Is the GitOps Toolkit related to the GitOps Engine?"},{"location":"get-started/","text":"Get started with GitOps Toolkit \u00b6 Prerequisites \u00b6 You will need two Kubernetes clusters version 1.16 or newer and kubectl version 1.18. For a quick local test, you can use Kubernetes kind . Any other Kubernetes setup will work as well though. In order to follow the guide you'll need a GitHub account and a personal access token that can create repositories (check all permissions under repo ). Export your GitHub personal access token and username: export GITHUB_TOKEN = <your-token> export GITHUB_USER = <your-username> Install the toolkit CLI \u00b6 To install the latest tk release run: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the tk binary to /usr/local/bin . Binaries for macOS and Linux AMD64 are available for download on the release page . To configure your shell to load tk completions add to your bash profile: # ~/.bashrc or ~/.bash_profile . < ( tk completion ) GitOps workflow \u00b6 You'll be using a dedicated Git repository e.g. fleet-infra to manage one or more Kubernetes clusters. This guide assumes that you have two clusters, one for staging and one for production. Using the toolkit CLI you'll do the following: configure each cluster to synchronise with a directory inside the fleet repository register app sources (git repositories) that contain plain Kubernetes manifests or Kustomize overlays configure app deployments on both clusters (pre-releases on staging, semver releases on production) Staging bootstrap \u00b6 Create the staging cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name staging kubectl cluster-info --context kind-staging Verify that your staging cluster satisfies the prerequisites with: $ tk check --pre \u25ba checking prerequisites \u2714 kubectl 1.18.3 >=1.18.0 \u2714 kubernetes 1.18.2 >=1.16.0 \u2714 prerequisites checks passed Run the bootstrap command: tk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = staging-cluster \\ --personal The bootstrap command creates a repository if one doesn't exist and commits the toolkit components manifests to the master branch at the specified path. Then it configures the target cluster to synchronize with the specified path inside the repository. If you wish to create the repository under a GitHub organization: tk bootstrap github \\ --owner = <organization> \\ --repository = <repo-name> \\ --team = <team1-slug> \\ --team = <team2-slug> \\ --path = staging-cluster Example output: $ tk bootstrap github --owner=gitopsrun --repository=fleet-infra --path=staging-cluster --team=devs \u25ba connecting to github.com \u2714 repository created \u2714 devs team access granted \u2714 repository cloned \u271a generating manifests \u2714 components manifests pushed \u25ba installing components in gitops-system namespace deployment \"source-controller\" successfully rolled out deployment \"kustomize-controller\" successfully rolled out deployment \"notification-controller\" successfully rolled out \u2714 install completed \u25ba configuring deploy key \u2714 deploy key configured \u25ba generating sync manifests \u2714 sync manifests pushed \u25ba applying sync manifests \u25ce waiting for cluster sync \u2714 bootstrap finished If you prefer GitLab, export GITLAB_TOKEN env var and use the command tk bootstrap gitlab . Idempotency It is safe to run the bootstrap command as many times as you want. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. You can target a specific toolkit version with tk bootstrap --version=<semver> . Staging workflow \u00b6 Clone the repository with: git clone https://github.com/ $GITHUB_USER /fleet-infra cd fleet-infra Create a git source pointing to a public repository master branch: tk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --branch = master \\ --interval = 30s \\ --export > ./staging-cluster/webapp-source.yaml Create a kustomization for synchronizing the common manifests on the cluster: tk create kustomization webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/common\" \\ --prune = true \\ --validation = client \\ --interval = 1h \\ --export > ./staging-cluster/webapp-common.yaml Create a kustomization for the backend service that depends on common: tk create kustomization webapp-backend \\ --depends-on = webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/backend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/backend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-backend.yaml Create a kustomization for the frontend service that depends on backend: tk create kustomization webapp-frontend \\ --depends-on = webapp-backend \\ --source = webapp \\ --path = \"./deploy/webapp/frontend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-frontend.yaml Push changes to origin: git add -A && git commit -m \"add staging webapp\" && git push In about 30s the synchronization should start: $ watch tk get kustomizations \u2714 gitops-system last applied revision master/35d5765a1acb9e9ce66cad7274c6fe03eee1e8eb \u2714 webapp-backend reconciling \u2714 webapp-common last applied revision master/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf \u2717 webapp-frontend dependency 'gitops-system/webapp-backend' is not ready When the synchronization finishes you can check that the webapp services are running: $ kubectl -n webapp get deployments,services NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/backend 1/1 1 1 4m1s deployment.apps/frontend 1/1 1 1 3m31s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/backend ClusterIP 10.52.10.22 <none> 9898/TCP,9999/TCP 4m1s service/frontend ClusterIP 10.52.9.85 <none> 80/TCP 3m31s Tip From this moment forward, any changes made to the webapp Kubernetes manifests in the master branch will be synchronised with the staging cluster. If a Kubernetes manifest is removed from the webapp repository, the reconciler will remove it from your cluster. If you delete a kustomization from the fleet-infra repo, the reconciler will remove all Kubernetes objects that were previously applied from that kustomization. If you alter the webapp deployment using kubectl edit , the changes will be reverted to match the state described in git. When dealing with an incident, you can pause the reconciliation of a kustomization with tk suspend kustomization <name> . Once the debugging session is over, you can re-enable the reconciliation with tk resume kustomization <name> . Production bootstrap \u00b6 On production clusters, you may wish to deploy stable releases of an application. When creating a git source instead of a branch, you can specify a git tag or a semver expression. Create the production cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name production kubectl cluster-info --context kind-production Run the bootstrap for the production environment: tk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = prod-cluster \\ --personal Pull the changes locally: git pull Production workflow \u00b6 Create a git source using a semver range to target stable releases: tk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <4.0.2\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml Create a kustomization for webapp pointing to the production overlay: tk create kustomization webapp \\ --source = webapp \\ --path = \"./deploy/overlays/production\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.production\" \\ --health-check = \"Deployment/backend.production\" \\ --health-check-timeout = 2m \\ --export > ./prod-cluster/webapp-production.yaml Push changes to origin: git add -A && git commit -m \"add prod webapp\" && git push List git sources: $ tk get sources git \u2714 gitops-system last fetched revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last fetched revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gitops-system get gitrepositories . List kustomization: $ tk get kustomizations \u2714 gitops-system last applied revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last applied revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gitops-system get kustomizations . If you want to upgrade to the latest 4.x version, you can change the semver expression to: tk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <5.0.0\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml git add -A && git commit -m \"update prod webapp\" && git push Trigger a git sync: $ tk reconcile ks gitops-system --with-source \u25ba annotating source gitops-system \u2714 source annotated \u25ce waiting for reconcilitation \u2714 git reconciliation completed \u2714 fetched revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u25ce waiting for kustomization reconcilitation \u2714 kustomization reconcilitation completed \u2714 applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 The kubectl equivalent is kubectl -n gitops-system annotate gitrepository/gitops-system fluxcd.io/reconcileAt=\"$(date +%s)\" . Wait for the webapp to be upgraded: $ watch tk get kustomizations \u2714 gitops-system last applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u2714 webapp last applied revision 4.0.5/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf","title":"Get Started"},{"location":"get-started/#get-started-with-gitops-toolkit","text":"","title":"Get started with GitOps Toolkit"},{"location":"get-started/#prerequisites","text":"You will need two Kubernetes clusters version 1.16 or newer and kubectl version 1.18. For a quick local test, you can use Kubernetes kind . Any other Kubernetes setup will work as well though. In order to follow the guide you'll need a GitHub account and a personal access token that can create repositories (check all permissions under repo ). Export your GitHub personal access token and username: export GITHUB_TOKEN = <your-token> export GITHUB_USER = <your-username>","title":"Prerequisites"},{"location":"get-started/#install-the-toolkit-cli","text":"To install the latest tk release run: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the tk binary to /usr/local/bin . Binaries for macOS and Linux AMD64 are available for download on the release page . To configure your shell to load tk completions add to your bash profile: # ~/.bashrc or ~/.bash_profile . < ( tk completion )","title":"Install the toolkit CLI"},{"location":"get-started/#gitops-workflow","text":"You'll be using a dedicated Git repository e.g. fleet-infra to manage one or more Kubernetes clusters. This guide assumes that you have two clusters, one for staging and one for production. Using the toolkit CLI you'll do the following: configure each cluster to synchronise with a directory inside the fleet repository register app sources (git repositories) that contain plain Kubernetes manifests or Kustomize overlays configure app deployments on both clusters (pre-releases on staging, semver releases on production)","title":"GitOps workflow"},{"location":"get-started/#staging-bootstrap","text":"Create the staging cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name staging kubectl cluster-info --context kind-staging Verify that your staging cluster satisfies the prerequisites with: $ tk check --pre \u25ba checking prerequisites \u2714 kubectl 1.18.3 >=1.18.0 \u2714 kubernetes 1.18.2 >=1.16.0 \u2714 prerequisites checks passed Run the bootstrap command: tk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = staging-cluster \\ --personal The bootstrap command creates a repository if one doesn't exist and commits the toolkit components manifests to the master branch at the specified path. Then it configures the target cluster to synchronize with the specified path inside the repository. If you wish to create the repository under a GitHub organization: tk bootstrap github \\ --owner = <organization> \\ --repository = <repo-name> \\ --team = <team1-slug> \\ --team = <team2-slug> \\ --path = staging-cluster Example output: $ tk bootstrap github --owner=gitopsrun --repository=fleet-infra --path=staging-cluster --team=devs \u25ba connecting to github.com \u2714 repository created \u2714 devs team access granted \u2714 repository cloned \u271a generating manifests \u2714 components manifests pushed \u25ba installing components in gitops-system namespace deployment \"source-controller\" successfully rolled out deployment \"kustomize-controller\" successfully rolled out deployment \"notification-controller\" successfully rolled out \u2714 install completed \u25ba configuring deploy key \u2714 deploy key configured \u25ba generating sync manifests \u2714 sync manifests pushed \u25ba applying sync manifests \u25ce waiting for cluster sync \u2714 bootstrap finished If you prefer GitLab, export GITLAB_TOKEN env var and use the command tk bootstrap gitlab . Idempotency It is safe to run the bootstrap command as many times as you want. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. You can target a specific toolkit version with tk bootstrap --version=<semver> .","title":"Staging bootstrap"},{"location":"get-started/#staging-workflow","text":"Clone the repository with: git clone https://github.com/ $GITHUB_USER /fleet-infra cd fleet-infra Create a git source pointing to a public repository master branch: tk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --branch = master \\ --interval = 30s \\ --export > ./staging-cluster/webapp-source.yaml Create a kustomization for synchronizing the common manifests on the cluster: tk create kustomization webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/common\" \\ --prune = true \\ --validation = client \\ --interval = 1h \\ --export > ./staging-cluster/webapp-common.yaml Create a kustomization for the backend service that depends on common: tk create kustomization webapp-backend \\ --depends-on = webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/backend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/backend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-backend.yaml Create a kustomization for the frontend service that depends on backend: tk create kustomization webapp-frontend \\ --depends-on = webapp-backend \\ --source = webapp \\ --path = \"./deploy/webapp/frontend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-frontend.yaml Push changes to origin: git add -A && git commit -m \"add staging webapp\" && git push In about 30s the synchronization should start: $ watch tk get kustomizations \u2714 gitops-system last applied revision master/35d5765a1acb9e9ce66cad7274c6fe03eee1e8eb \u2714 webapp-backend reconciling \u2714 webapp-common last applied revision master/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf \u2717 webapp-frontend dependency 'gitops-system/webapp-backend' is not ready When the synchronization finishes you can check that the webapp services are running: $ kubectl -n webapp get deployments,services NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/backend 1/1 1 1 4m1s deployment.apps/frontend 1/1 1 1 3m31s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/backend ClusterIP 10.52.10.22 <none> 9898/TCP,9999/TCP 4m1s service/frontend ClusterIP 10.52.9.85 <none> 80/TCP 3m31s Tip From this moment forward, any changes made to the webapp Kubernetes manifests in the master branch will be synchronised with the staging cluster. If a Kubernetes manifest is removed from the webapp repository, the reconciler will remove it from your cluster. If you delete a kustomization from the fleet-infra repo, the reconciler will remove all Kubernetes objects that were previously applied from that kustomization. If you alter the webapp deployment using kubectl edit , the changes will be reverted to match the state described in git. When dealing with an incident, you can pause the reconciliation of a kustomization with tk suspend kustomization <name> . Once the debugging session is over, you can re-enable the reconciliation with tk resume kustomization <name> .","title":"Staging workflow"},{"location":"get-started/#production-bootstrap","text":"On production clusters, you may wish to deploy stable releases of an application. When creating a git source instead of a branch, you can specify a git tag or a semver expression. Create the production cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name production kubectl cluster-info --context kind-production Run the bootstrap for the production environment: tk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = prod-cluster \\ --personal Pull the changes locally: git pull","title":"Production bootstrap"},{"location":"get-started/#production-workflow","text":"Create a git source using a semver range to target stable releases: tk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <4.0.2\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml Create a kustomization for webapp pointing to the production overlay: tk create kustomization webapp \\ --source = webapp \\ --path = \"./deploy/overlays/production\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.production\" \\ --health-check = \"Deployment/backend.production\" \\ --health-check-timeout = 2m \\ --export > ./prod-cluster/webapp-production.yaml Push changes to origin: git add -A && git commit -m \"add prod webapp\" && git push List git sources: $ tk get sources git \u2714 gitops-system last fetched revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last fetched revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gitops-system get gitrepositories . List kustomization: $ tk get kustomizations \u2714 gitops-system last applied revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last applied revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gitops-system get kustomizations . If you want to upgrade to the latest 4.x version, you can change the semver expression to: tk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <5.0.0\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml git add -A && git commit -m \"update prod webapp\" && git push Trigger a git sync: $ tk reconcile ks gitops-system --with-source \u25ba annotating source gitops-system \u2714 source annotated \u25ce waiting for reconcilitation \u2714 git reconciliation completed \u2714 fetched revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u25ce waiting for kustomization reconcilitation \u2714 kustomization reconcilitation completed \u2714 applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 The kubectl equivalent is kubectl -n gitops-system annotate gitrepository/gitops-system fluxcd.io/reconcileAt=\"$(date +%s)\" . Wait for the webapp to be upgraded: $ watch tk get kustomizations \u2714 gitops-system last applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u2714 webapp last applied revision 4.0.5/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf","title":"Production workflow"},{"location":"guides/helmreleases/","text":"Manage Helm Releases \u00b6 The helm-controller allows you to declaratively manage Helm chart releases with Kubernetes manifests. It makes use of the artifacts produced by the source-controller from HelmRepository and HelmChart resources. The helm-controller is part of the default toolkit installation. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Define a Helm repository \u00b6 To be able to deploy a Helm chart, the Helm chart repository has to be known first to the source-controller, so that the HelmRelease can reference to it. A cluster administrator should register trusted sources by creating HelmRepository resources in the gitops-system namespace. By default, the source-controller watches for sources only in the gitops-system namespace, this way cluster admins can prevent untrusted sources from being registered by users. apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : podinfo namespace : gitops-system spec : interval : 1m url : https://stefanprodan.github.io/podinfo The interval defines at which interval the Helm repository index is fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S Helm repository URL. Authentication HTTP/S basic and TLS authentication can be configured for private Helm repositories. See the HelmRepository CRD docs for more details. Define a Helm release \u00b6 With the HelmRepository created, define a new HelmRelease to deploy the Helm chart from the repository: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : gitops-system interval : 1m values : replicaCount : 2 The chart.name is the name of the chart as made available by the Helm repository, and may not include any aliases. The chart.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <4.0.2 ). The chart values are used by the helm-controller as a template to create a new HelmChart resource in the same namespace as the sourceRef . The source-controller will then lookup the chart in the artifact of the referenced HelmRepository , fetch the chart, and make it available as a HelmChart artifact to be used by the helm-controller. Note The HelmRelease offers an extensive set of configurable flags for finer grain control over how Helm actions are performed. See the HelmRelease CRD docs for more details. Refer to values in ConfigMap and Secret resources \u00b6 It is possible to define a list of ConfigMap and Secret resources from which to take values. The values are merged in the order given, with the later values overwriting earlier. These values always have a lower priority than the values inlined in the HelmRelease via the spec.values parameter. spec : valuesFrom : - kind : ConfigMap name : prod-env-values - kind : Secret name : prod-secret-values valuesKey : secret.yaml The definition of the listed keys is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The key in the referent the values can be found at. Defaults to values.yaml when ommitted. Configure notifications \u00b6 The default toolkit installation configures the helm-controller to broadcast events to the notification-controller . To receive the events as notifications, a Provider needs to be setup first as described in the notifications guide . Once you have set up the Provider , create a new Alert resource in the gitops-system to start receiving notifications about the Helm release: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : generation : 2 name : helm-podinfo namespace : gitops-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : HelmRepository name : podinfo - kind : HelmChart name : default-podinfo - kind : HelmRelease name : podinfo namespace : default Configure webhook receivers \u00b6 When using semver ranges for Helm releases, you may want to trigger an update as soon as a new chart version is published to your Helm repository. In order to notify source-controller about a chart update, you can setup webhook receivers . First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN When using Harbor as your Helm repository, you can define a receiver with: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : helm-podinfo namespace : gitops-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : podinfo The notification-controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gitops-system get receiver/helm-podinfo NAME READY STATUS helm-podinfo True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b Log in to the Harbor interface, go to Projects, select a project, and select Webhooks. Fill the form with: Endpoint URL: compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Auth Header: use the token string With the above settings, when you upload a chart, the following happens: Harbor sends the chart push event to the receiver address Notification controller validates the authenticity of the payload using the auth header Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the HelmChart version Helm controller is notified about the version change and upgrades the release Note Besides Harbor, you can define receivers for GitHub , GitLab , Bitbucket and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details.","title":"Manage Helm Releases"},{"location":"guides/helmreleases/#manage-helm-releases","text":"The helm-controller allows you to declaratively manage Helm chart releases with Kubernetes manifests. It makes use of the artifacts produced by the source-controller from HelmRepository and HelmChart resources. The helm-controller is part of the default toolkit installation.","title":"Manage Helm Releases"},{"location":"guides/helmreleases/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide .","title":"Prerequisites"},{"location":"guides/helmreleases/#define-a-helm-repository","text":"To be able to deploy a Helm chart, the Helm chart repository has to be known first to the source-controller, so that the HelmRelease can reference to it. A cluster administrator should register trusted sources by creating HelmRepository resources in the gitops-system namespace. By default, the source-controller watches for sources only in the gitops-system namespace, this way cluster admins can prevent untrusted sources from being registered by users. apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : podinfo namespace : gitops-system spec : interval : 1m url : https://stefanprodan.github.io/podinfo The interval defines at which interval the Helm repository index is fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S Helm repository URL. Authentication HTTP/S basic and TLS authentication can be configured for private Helm repositories. See the HelmRepository CRD docs for more details.","title":"Define a Helm repository"},{"location":"guides/helmreleases/#define-a-helm-release","text":"With the HelmRepository created, define a new HelmRelease to deploy the Helm chart from the repository: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : name : podinfo version : '^4.0.0' sourceRef : kind : HelmRepository name : podinfo namespace : gitops-system interval : 1m values : replicaCount : 2 The chart.name is the name of the chart as made available by the Helm repository, and may not include any aliases. The chart.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <4.0.2 ). The chart values are used by the helm-controller as a template to create a new HelmChart resource in the same namespace as the sourceRef . The source-controller will then lookup the chart in the artifact of the referenced HelmRepository , fetch the chart, and make it available as a HelmChart artifact to be used by the helm-controller. Note The HelmRelease offers an extensive set of configurable flags for finer grain control over how Helm actions are performed. See the HelmRelease CRD docs for more details.","title":"Define a Helm release"},{"location":"guides/helmreleases/#refer-to-values-in-configmap-and-secret-resources","text":"It is possible to define a list of ConfigMap and Secret resources from which to take values. The values are merged in the order given, with the later values overwriting earlier. These values always have a lower priority than the values inlined in the HelmRelease via the spec.values parameter. spec : valuesFrom : - kind : ConfigMap name : prod-env-values - kind : Secret name : prod-secret-values valuesKey : secret.yaml The definition of the listed keys is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The key in the referent the values can be found at. Defaults to values.yaml when ommitted.","title":"Refer to values in ConfigMap and Secret resources"},{"location":"guides/helmreleases/#configure-notifications","text":"The default toolkit installation configures the helm-controller to broadcast events to the notification-controller . To receive the events as notifications, a Provider needs to be setup first as described in the notifications guide . Once you have set up the Provider , create a new Alert resource in the gitops-system to start receiving notifications about the Helm release: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : generation : 2 name : helm-podinfo namespace : gitops-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : HelmRepository name : podinfo - kind : HelmChart name : default-podinfo - kind : HelmRelease name : podinfo namespace : default","title":"Configure notifications"},{"location":"guides/helmreleases/#configure-webhook-receivers","text":"When using semver ranges for Helm releases, you may want to trigger an update as soon as a new chart version is published to your Helm repository. In order to notify source-controller about a chart update, you can setup webhook receivers . First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN When using Harbor as your Helm repository, you can define a receiver with: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : helm-podinfo namespace : gitops-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : podinfo The notification-controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gitops-system get receiver/helm-podinfo NAME READY STATUS helm-podinfo True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b Log in to the Harbor interface, go to Projects, select a project, and select Webhooks. Fill the form with: Endpoint URL: compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Auth Header: use the token string With the above settings, when you upload a chart, the following happens: Harbor sends the chart push event to the receiver address Notification controller validates the authenticity of the payload using the auth header Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the HelmChart version Helm controller is notified about the version change and upgrades the release Note Besides Harbor, you can define receivers for GitHub , GitLab , Bitbucket and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details.","title":"Configure webhook receivers"},{"location":"guides/installation/","text":"Installation \u00b6 This guide walks you through setting up the GitOps Toolkit to manage one or more Kubernetes clusters. Prerequisites \u00b6 You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer. Install the toolkit CLI with: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the tk binary to /usr/local/bin . Binaries for macOS and Linux AMD64 are available for download on the release page . Verify that your cluster satisfies the prerequisites with: tk check --pre Bootstrap \u00b6 Using the tk bootstrap command you can install the toolkit on a Kubernetes cluster and configure it to manage itself from a Git repository. The bootstrap creates a Git repository if one doesn't exist and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with that repository by setting up SSH deploy keys. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. The bootstrap is idempotent, it's safe to run the command as many times as you want. You can choose what components to install and for which cluster with: tk bootstrap <GIT-PROVIDER> \\ --components = source-controller,kustomize-controller,helm-controller,notification-controller \\ --path = my-cluster \\ --version = latest If you wish to install a specific version, use the toolkit release tag e.g. --version=v0.0.14 . With --path you can configure the directory which will be used to reconcile the target cluster. To control multiple clusters from the same Git repository, you have to set a unique path per cluster e.g. staging-cluster and production-cluster : \u251c\u2500\u2500 staging-cluster # <- path=staging-cluster \u2502 \u2514\u2500\u2500 gitops-system # <- namespace dir generated by bootstrap \u2502 \u251c\u2500\u2500 toolkit-components.yaml \u2502 \u251c\u2500\u2500 toolkit-kustomization.yaml \u2502 \u2514\u2500\u2500 toolkit-source.yaml \u2514\u2500\u2500 production-cluster # <- path=production-cluster \u2514\u2500\u2500 gitops-system GitHub and GitHub Enterprise \u00b6 Generate a personal access token that can create repositories by checking all permissions under repo . Export your GitHub personal access token as an environment variable: export GITHUB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitHub account: tk bootstrap github \\ --owner = my-github-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitHub organization: tk bootstrap github \\ --owner = my-github-organization \\ --repository = my-repository \\ --team = team1-slug \\ --team = team2-slug \\ --path = my-cluster When you specify a list of teams, those teams will be granted maintainer access to the repository. To run the bootstrap for a repository hosted on GitHub Enterprise, you have to specify your GitHub hostname: tk bootstrap github \\ --hostname = my-github-enterprise.com \\ --owner = my-github-organization \\ --repository = my-repository \\ --path = my-cluster GitLab and GitLab Enterprise \u00b6 Generate a personal access token that grants complete read/write access to the GitLab API. Export your GitLab personal access token as an environment variable: export GITLAB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitLab account: tk bootstrap gitlab \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitLab group: tk bootstrap gitlab \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --path = my-cluster To run the bootstrap for a repository hosted on GitLab on-prem or enterprise, you have to specify your GitLab hostname: tk bootstrap gitlab \\ --hostname = my-gitlab.com \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --path = my-cluster Generic Git Server \u00b6 For other Git providers such as Bitbucket, Gogs, Gitea, etc you can manually setup the repository and the deploy key. Create a Git repository and clone it locally: git clone ssh://<host>/<org>/my-repository cd my-repository Create a directory inside the repository: mkdir -p ./my-cluster/gitops-system Generate the toolkit manifests with: tk install --version = latest \\ --export > ./my-cluster/gitops-system/toolkit-components.yaml If your cluster must pull images from a private container registry, first you should pull the toolkit images from Docker Hub and push them to your registry, for example: docker pull fluxcd/source-controller:v0.0.7 docker tag fluxcd/source-controller:v0.0.7 registry.internal/fluxcd/source-controller:v0.0.7 docker push registry.internal/fluxcd/source-controller:v0.0.7 Create the pull secret in the gitops-system namespace: kubectl create ns gitops-system kubectl -n gitops-system create secret generic regcred \\ --from-file = .dockerconfigjson = /.docker/config.json \\ --type = kubernetes.io/dockerconfigjson Set your registry domain, and the pull secret when generating the manifests: tk install --version = latest \\ --registry = registry.internal/fluxcd \\ --image-pull-secret = regcred \\ --export > ./my-cluster/gitops-system/toolkit-components.yaml Commit and push the manifest to the master branch: git add -A && git commit -m \"add toolkit manifests\" && git push Apply the manifests on your cluster: kubectl apply -f ./my-cluster/gitops-system/toolkit-components.yaml Verify that the toolkit controllers have started: tk check Create a GitRepository object on your cluster by specifying the SSH address of your repo: tk create source git gitops-system \\ --url = ssh://<host>/<org>/my-repository \\ --ssh-key-algorithm = ecdsa \\ --ssh-ecdsa-curve = p521 \\ --branch = master \\ --interval = 1m You will be prompted to add a deploy key to your repository. If you don't specify the SSH algorithm, then tk will generate an RSA 2048 bits key. If your Git server supports basic auth, you can set the URL to HTTPS and specify the credentials with: tk create source git gitops-system \\ --url = https://<host>/<org>/my-repository \\ --username = my-username \\ --password = my-password \\ --branch = master \\ --interval = 1m Create a Kustomization object on your cluster: tk create kustomization gitops-system \\ --source = gitops-system \\ --path = \"./my-cluster\" \\ --prune = true \\ --interval = 10m Export both objects, commit and push the manifests to Git: tk export source git gitops-system \\ > ./my-cluster/gitops-system/toolkit-source.yaml tk export kustomization gitops-system \\ > ./my-cluster/gitops-system/toolkit-kustomization.yaml git add -A && git commit -m \"add toolkit reconciliation\" && git push To upgrade the toolkit to a newer version, run the install command and commit the changes: tk install --version = latest \\ --export > ./my-cluster/gitops-system/toolkit-components.yaml git add -A && git commit -m \"update toolkit\" && git push The source-controller will pull the changes on the cluster, then the kustomize-controller will perform a rolling update of all toolkit components including itself. Dev install \u00b6 For testing purposes you can install the toolkit without storing its manifests in a Git repository. Here is the equivalent to fluxctl install : tk install \\ --components = source-controller,kustomize-controller Then you can register Git repositories and reconcile them on your cluster: tk create source git podinfo \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0\" \\ --interval = 1m tk create kustomization podinfo-default \\ --source = podinfo \\ --path = \"./kustomize\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/podinfo.default\" \\ --health-check-timeout = 2m Here is the equivalent to helm install helm-operator : tk install \\ --components = source-controller,kustomize-controller,helm-controller Then you can register Helm repositories and create Helm releases: tk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com tk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gitops-system \\ --source = stable \\ --chart-name = sealed-secrets \\ --chart-version = \"^1.10.0\" Monitoring with Prometheus and Grafana \u00b6 The GitOps Toolkit comes with an optional monitoring stack. You can install the stack in the gitops-system namespace with: kustomize build github.com/fluxcd/toolkit/manifests/monitoring?ref=master | kubectl apply -f- The monitoring stack is composed of: Prometheus server - collects metrics from the toolkit controllers and stores them for 2h Grafana dashboards - displays the control plane resource usage and reconciliation stats If you wish to use your own Prometheus and Grafana instances, then you can import the dashboards from GitHub . Hint Note that the toolkit controllers expose the /metrics endpoint on port 8080 . When using Prometheus Operator you should create PodMonitor objects to configure scraping. When Prometheus is running outside of the gitops-system namespace, you have to create a network policy that allows traffic on port 8080 from the namespace where Prometheus is deployed.","title":"Installation"},{"location":"guides/installation/#installation","text":"This guide walks you through setting up the GitOps Toolkit to manage one or more Kubernetes clusters.","title":"Installation"},{"location":"guides/installation/#prerequisites","text":"You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer. Install the toolkit CLI with: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the tk binary to /usr/local/bin . Binaries for macOS and Linux AMD64 are available for download on the release page . Verify that your cluster satisfies the prerequisites with: tk check --pre","title":"Prerequisites"},{"location":"guides/installation/#bootstrap","text":"Using the tk bootstrap command you can install the toolkit on a Kubernetes cluster and configure it to manage itself from a Git repository. The bootstrap creates a Git repository if one doesn't exist and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with that repository by setting up SSH deploy keys. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. The bootstrap is idempotent, it's safe to run the command as many times as you want. You can choose what components to install and for which cluster with: tk bootstrap <GIT-PROVIDER> \\ --components = source-controller,kustomize-controller,helm-controller,notification-controller \\ --path = my-cluster \\ --version = latest If you wish to install a specific version, use the toolkit release tag e.g. --version=v0.0.14 . With --path you can configure the directory which will be used to reconcile the target cluster. To control multiple clusters from the same Git repository, you have to set a unique path per cluster e.g. staging-cluster and production-cluster : \u251c\u2500\u2500 staging-cluster # <- path=staging-cluster \u2502 \u2514\u2500\u2500 gitops-system # <- namespace dir generated by bootstrap \u2502 \u251c\u2500\u2500 toolkit-components.yaml \u2502 \u251c\u2500\u2500 toolkit-kustomization.yaml \u2502 \u2514\u2500\u2500 toolkit-source.yaml \u2514\u2500\u2500 production-cluster # <- path=production-cluster \u2514\u2500\u2500 gitops-system","title":"Bootstrap"},{"location":"guides/installation/#github-and-github-enterprise","text":"Generate a personal access token that can create repositories by checking all permissions under repo . Export your GitHub personal access token as an environment variable: export GITHUB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitHub account: tk bootstrap github \\ --owner = my-github-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitHub organization: tk bootstrap github \\ --owner = my-github-organization \\ --repository = my-repository \\ --team = team1-slug \\ --team = team2-slug \\ --path = my-cluster When you specify a list of teams, those teams will be granted maintainer access to the repository. To run the bootstrap for a repository hosted on GitHub Enterprise, you have to specify your GitHub hostname: tk bootstrap github \\ --hostname = my-github-enterprise.com \\ --owner = my-github-organization \\ --repository = my-repository \\ --path = my-cluster","title":"GitHub and GitHub Enterprise"},{"location":"guides/installation/#gitlab-and-gitlab-enterprise","text":"Generate a personal access token that grants complete read/write access to the GitLab API. Export your GitLab personal access token as an environment variable: export GITLAB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitLab account: tk bootstrap gitlab \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitLab group: tk bootstrap gitlab \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --path = my-cluster To run the bootstrap for a repository hosted on GitLab on-prem or enterprise, you have to specify your GitLab hostname: tk bootstrap gitlab \\ --hostname = my-gitlab.com \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --path = my-cluster","title":"GitLab and GitLab Enterprise"},{"location":"guides/installation/#generic-git-server","text":"For other Git providers such as Bitbucket, Gogs, Gitea, etc you can manually setup the repository and the deploy key. Create a Git repository and clone it locally: git clone ssh://<host>/<org>/my-repository cd my-repository Create a directory inside the repository: mkdir -p ./my-cluster/gitops-system Generate the toolkit manifests with: tk install --version = latest \\ --export > ./my-cluster/gitops-system/toolkit-components.yaml If your cluster must pull images from a private container registry, first you should pull the toolkit images from Docker Hub and push them to your registry, for example: docker pull fluxcd/source-controller:v0.0.7 docker tag fluxcd/source-controller:v0.0.7 registry.internal/fluxcd/source-controller:v0.0.7 docker push registry.internal/fluxcd/source-controller:v0.0.7 Create the pull secret in the gitops-system namespace: kubectl create ns gitops-system kubectl -n gitops-system create secret generic regcred \\ --from-file = .dockerconfigjson = /.docker/config.json \\ --type = kubernetes.io/dockerconfigjson Set your registry domain, and the pull secret when generating the manifests: tk install --version = latest \\ --registry = registry.internal/fluxcd \\ --image-pull-secret = regcred \\ --export > ./my-cluster/gitops-system/toolkit-components.yaml Commit and push the manifest to the master branch: git add -A && git commit -m \"add toolkit manifests\" && git push Apply the manifests on your cluster: kubectl apply -f ./my-cluster/gitops-system/toolkit-components.yaml Verify that the toolkit controllers have started: tk check Create a GitRepository object on your cluster by specifying the SSH address of your repo: tk create source git gitops-system \\ --url = ssh://<host>/<org>/my-repository \\ --ssh-key-algorithm = ecdsa \\ --ssh-ecdsa-curve = p521 \\ --branch = master \\ --interval = 1m You will be prompted to add a deploy key to your repository. If you don't specify the SSH algorithm, then tk will generate an RSA 2048 bits key. If your Git server supports basic auth, you can set the URL to HTTPS and specify the credentials with: tk create source git gitops-system \\ --url = https://<host>/<org>/my-repository \\ --username = my-username \\ --password = my-password \\ --branch = master \\ --interval = 1m Create a Kustomization object on your cluster: tk create kustomization gitops-system \\ --source = gitops-system \\ --path = \"./my-cluster\" \\ --prune = true \\ --interval = 10m Export both objects, commit and push the manifests to Git: tk export source git gitops-system \\ > ./my-cluster/gitops-system/toolkit-source.yaml tk export kustomization gitops-system \\ > ./my-cluster/gitops-system/toolkit-kustomization.yaml git add -A && git commit -m \"add toolkit reconciliation\" && git push To upgrade the toolkit to a newer version, run the install command and commit the changes: tk install --version = latest \\ --export > ./my-cluster/gitops-system/toolkit-components.yaml git add -A && git commit -m \"update toolkit\" && git push The source-controller will pull the changes on the cluster, then the kustomize-controller will perform a rolling update of all toolkit components including itself.","title":"Generic Git Server"},{"location":"guides/installation/#dev-install","text":"For testing purposes you can install the toolkit without storing its manifests in a Git repository. Here is the equivalent to fluxctl install : tk install \\ --components = source-controller,kustomize-controller Then you can register Git repositories and reconcile them on your cluster: tk create source git podinfo \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0\" \\ --interval = 1m tk create kustomization podinfo-default \\ --source = podinfo \\ --path = \"./kustomize\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/podinfo.default\" \\ --health-check-timeout = 2m Here is the equivalent to helm install helm-operator : tk install \\ --components = source-controller,kustomize-controller,helm-controller Then you can register Helm repositories and create Helm releases: tk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com tk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gitops-system \\ --source = stable \\ --chart-name = sealed-secrets \\ --chart-version = \"^1.10.0\"","title":"Dev install"},{"location":"guides/installation/#monitoring-with-prometheus-and-grafana","text":"The GitOps Toolkit comes with an optional monitoring stack. You can install the stack in the gitops-system namespace with: kustomize build github.com/fluxcd/toolkit/manifests/monitoring?ref=master | kubectl apply -f- The monitoring stack is composed of: Prometheus server - collects metrics from the toolkit controllers and stores them for 2h Grafana dashboards - displays the control plane resource usage and reconciliation stats If you wish to use your own Prometheus and Grafana instances, then you can import the dashboards from GitHub . Hint Note that the toolkit controllers expose the /metrics endpoint on port 8080 . When using Prometheus Operator you should create PodMonitor objects to configure scraping. When Prometheus is running outside of the gitops-system namespace, you have to create a network policy that allows traffic on port 8080 from the namespace where Prometheus is deployed.","title":"Monitoring with Prometheus and Grafana"},{"location":"guides/notifications/","text":"Setup Notifications \u00b6 When operating a cluster, different teams may wish to receive notifications about the status of their GitOps pipelines. For example, the on-call team would receive alerts about reconciliation failures in the cluster, while the dev team may wish to be alerted when a new version of an app was deployed and if the deployment is healthy. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The GitOps toolkit controllers emit Kubernetes events whenever a resource status changes. You can use the notification-controller to forward these events to Slack, Microsoft Teams, Discord or Rocket chart. The notification controller is part of the default toolkit installation. Define a provider \u00b6 First create a secret with your Slack incoming webhook: kubectl -n gitops-system create secret generic slack-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field, it can be a Slack, Microsoft Teams, Discord or Rocket webhook URL. Create a notification provider for Slack by referencing the above secret: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : slack namespace : gitops-system spec : type : slack channel : general secretRef : name : slack-url The provider type can be slack , msteams , discord , rocket or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. This way you can create custom handlers that can store the events in Elasticsearch, CloudWatch, Stackdriver, etc. Define an alert \u00b6 Create an alert definition for all repositories and kustomizations: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : on-call-webapp namespace : gitops-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : GitRepository name : '*' - kind : Kustomization name : '*' Apply the above files or commit them to the fleet-infra repository. To verify that the alert has been acknowledge by the notification controller do: $ kubectl -n gitops-system get alerts NAME READY STATUS AGE on-call-webapp True Initialized 1m Multiple alerts can be used to send notifications to different channels or Slack organizations. The event severity can be set to info or error . When the severity is set to error , the kustomize controller will alert on any error encountered during the reconciliation process. This includes kustomize build and validation errors, apply errors and health check failures. When the verbosity is set to info , the controller will alert if: a Kubernetes object was created, updated or deleted heath checks are passing a dependency is delaying the execution an error occurs","title":"Setup Notifications"},{"location":"guides/notifications/#setup-notifications","text":"When operating a cluster, different teams may wish to receive notifications about the status of their GitOps pipelines. For example, the on-call team would receive alerts about reconciliation failures in the cluster, while the dev team may wish to be alerted when a new version of an app was deployed and if the deployment is healthy.","title":"Setup Notifications"},{"location":"guides/notifications/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The GitOps toolkit controllers emit Kubernetes events whenever a resource status changes. You can use the notification-controller to forward these events to Slack, Microsoft Teams, Discord or Rocket chart. The notification controller is part of the default toolkit installation.","title":"Prerequisites"},{"location":"guides/notifications/#define-a-provider","text":"First create a secret with your Slack incoming webhook: kubectl -n gitops-system create secret generic slack-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field, it can be a Slack, Microsoft Teams, Discord or Rocket webhook URL. Create a notification provider for Slack by referencing the above secret: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : slack namespace : gitops-system spec : type : slack channel : general secretRef : name : slack-url The provider type can be slack , msteams , discord , rocket or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. This way you can create custom handlers that can store the events in Elasticsearch, CloudWatch, Stackdriver, etc.","title":"Define a provider"},{"location":"guides/notifications/#define-an-alert","text":"Create an alert definition for all repositories and kustomizations: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : on-call-webapp namespace : gitops-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : GitRepository name : '*' - kind : Kustomization name : '*' Apply the above files or commit them to the fleet-infra repository. To verify that the alert has been acknowledge by the notification controller do: $ kubectl -n gitops-system get alerts NAME READY STATUS AGE on-call-webapp True Initialized 1m Multiple alerts can be used to send notifications to different channels or Slack organizations. The event severity can be set to info or error . When the severity is set to error , the kustomize controller will alert on any error encountered during the reconciliation process. This includes kustomize build and validation errors, apply errors and health check failures. When the verbosity is set to info , the controller will alert if: a Kubernetes object was created, updated or deleted heath checks are passing a dependency is delaying the execution an error occurs","title":"Define an alert"},{"location":"guides/sealed-secrets/","text":"Sealed Secrets \u00b6 In order to store secrets safely in a public or private Git repository, you can use Bitnami's sealed-secrets controller and encrypt your Kubernetes Secrets into SealedSecrets. The sealed secrets can be decrypted only by the controller running in your cluster and nobody else can obtain the original secret, even if they have access to the Git repository. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The sealed-secrets controller comes with a companion CLI tool called kubeseal. With kubeseal you can create SealedSecret custom resources in YAML format and store those in your Git repository. Install the kubeseal CLI: brew install kubeseal For Linux or Windows you can download the kubeseal binary from GitHub . Deploy sealed-secrets with a HelmRelease \u00b6 You'll be using helm-controller APIs to install the sealed-secrets controller from its Helm chart . First you have to register the Helm repository where the sealed-secrets chart is published: tk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com With interval we configure source-controller to download the Helm repository index every hour. If a newer version of sealed-secrets is published, source-controller will signal helm-controller that a new chart is available. Create a Helm release that installs the latest version of sealed-secrets controller: tk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gitops-system \\ --source = stable \\ --chart-name = sealed-secrets \\ --chart-version = \"^1.10.0\" With chart version ^1.10.0 we configure helm-controller to automatically upgrade the release when a new chart version is fetch by source-controller. At startup, the sealed-secrets controller generates a 4096-bit RSA key pair and persists the private and public keys as Kubernetes secrets in the gitops-system namespace. You can retrieve the public key with: kubeseal --fetch-cert \\ --controller-name = sealed-secrets \\ --controller-namespace = gitops-system \\ > pub-sealed-secrets.pem The public key can be safely stored in Git, and can be used to encrypt secrets without direct access to the Kubernetes cluster. Encrypt secrets \u00b6 Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run \\ -o yaml > basic-auth.yaml Encrypt the secret with kubeseal: kubeseal --format = yaml --cert = pub-sealed-secrets.pem \\ < basic-auth.yaml > basic-auth-sealed.yaml Delete the plain secret and apply the sealed one: rm basic-auth.yaml kubectl apply -f basic-auth-sealed.yaml Verify that the sealed-secrets controller has created the basic-auth Kubernetes Secret: $ kubectl -n default get secrets basic-auth NAME TYPE DATA AGE basic-auth Opaque 2 1m43s GitOps workflow \u00b6 A cluster admin should add the stable HelmRepository manifest and the sealed-secrets HelmRelease to the fleet repository. Helm repository manifest: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : stable namespace : gitops-system spec : interval : 1h0m0s url : https://kubernetes-charts.storage.googleapis.com Helm release manifest: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : sealed-secrets namespace : gitops-system spec : chart : name : sealed-secrets sourceRef : kind : HelmRepository name : stable version : \"^1.10.0\" interval : 1h0m0s releaseName : sealed-secrets targetNamespace : gitops-system Hint You can generate the above manifests using tk create <kind> --export > manifest.yaml . Once the sealed-secrets controller is installed, the admin fetches the public key and shares it with the teams that operate on the fleet clusters via Git. When a team member wants to create a Kubernetes Secret on a cluster, they uses kubeseal and the public key corresponding to that cluster to generate a SealedSecret. Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret with kubeseal as db-auth-sealed.yaml delete the original secret file db-auth.yaml create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var using the original name db-auth commit the manifests db-auth-sealed.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller applies the SealedSecret and the Deployment manifests sealed-secrets controller decrypts the SealedSecret and creates a Kubernetes Secret kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"Sealed Secrets"},{"location":"guides/sealed-secrets/#sealed-secrets","text":"In order to store secrets safely in a public or private Git repository, you can use Bitnami's sealed-secrets controller and encrypt your Kubernetes Secrets into SealedSecrets. The sealed secrets can be decrypted only by the controller running in your cluster and nobody else can obtain the original secret, even if they have access to the Git repository.","title":"Sealed Secrets"},{"location":"guides/sealed-secrets/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The sealed-secrets controller comes with a companion CLI tool called kubeseal. With kubeseal you can create SealedSecret custom resources in YAML format and store those in your Git repository. Install the kubeseal CLI: brew install kubeseal For Linux or Windows you can download the kubeseal binary from GitHub .","title":"Prerequisites"},{"location":"guides/sealed-secrets/#deploy-sealed-secrets-with-a-helmrelease","text":"You'll be using helm-controller APIs to install the sealed-secrets controller from its Helm chart . First you have to register the Helm repository where the sealed-secrets chart is published: tk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com With interval we configure source-controller to download the Helm repository index every hour. If a newer version of sealed-secrets is published, source-controller will signal helm-controller that a new chart is available. Create a Helm release that installs the latest version of sealed-secrets controller: tk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gitops-system \\ --source = stable \\ --chart-name = sealed-secrets \\ --chart-version = \"^1.10.0\" With chart version ^1.10.0 we configure helm-controller to automatically upgrade the release when a new chart version is fetch by source-controller. At startup, the sealed-secrets controller generates a 4096-bit RSA key pair and persists the private and public keys as Kubernetes secrets in the gitops-system namespace. You can retrieve the public key with: kubeseal --fetch-cert \\ --controller-name = sealed-secrets \\ --controller-namespace = gitops-system \\ > pub-sealed-secrets.pem The public key can be safely stored in Git, and can be used to encrypt secrets without direct access to the Kubernetes cluster.","title":"Deploy sealed-secrets with a HelmRelease"},{"location":"guides/sealed-secrets/#encrypt-secrets","text":"Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run \\ -o yaml > basic-auth.yaml Encrypt the secret with kubeseal: kubeseal --format = yaml --cert = pub-sealed-secrets.pem \\ < basic-auth.yaml > basic-auth-sealed.yaml Delete the plain secret and apply the sealed one: rm basic-auth.yaml kubectl apply -f basic-auth-sealed.yaml Verify that the sealed-secrets controller has created the basic-auth Kubernetes Secret: $ kubectl -n default get secrets basic-auth NAME TYPE DATA AGE basic-auth Opaque 2 1m43s","title":"Encrypt secrets"},{"location":"guides/sealed-secrets/#gitops-workflow","text":"A cluster admin should add the stable HelmRepository manifest and the sealed-secrets HelmRelease to the fleet repository. Helm repository manifest: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : stable namespace : gitops-system spec : interval : 1h0m0s url : https://kubernetes-charts.storage.googleapis.com Helm release manifest: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : sealed-secrets namespace : gitops-system spec : chart : name : sealed-secrets sourceRef : kind : HelmRepository name : stable version : \"^1.10.0\" interval : 1h0m0s releaseName : sealed-secrets targetNamespace : gitops-system Hint You can generate the above manifests using tk create <kind> --export > manifest.yaml . Once the sealed-secrets controller is installed, the admin fetches the public key and shares it with the teams that operate on the fleet clusters via Git. When a team member wants to create a Kubernetes Secret on a cluster, they uses kubeseal and the public key corresponding to that cluster to generate a SealedSecret. Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret with kubeseal as db-auth-sealed.yaml delete the original secret file db-auth.yaml create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var using the original name db-auth commit the manifests db-auth-sealed.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller applies the SealedSecret and the Deployment manifests sealed-secrets controller decrypts the SealedSecret and creates a Kubernetes Secret kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"GitOps workflow"},{"location":"guides/webhook-receivers/","text":"Setup Webhook Receivers \u00b6 The GitOps toolkit controllers are by design pull-based . In order to notify the controllers about changes in Git or Helm repositories, you can setup webhooks and trigger a cluster reconciliation every time a source changes. Using webhook receivers, you can build push-based GitOps pipelines that react to external events. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The notification controller can handle events coming from external systems (GitHub, GitLab, Bitbucket, Harbour, Jenkins, etc) and notify the GitOps toolkit controllers about source changes. The notification controller is part of the default toolkit installation. Expose the webhook receiver \u00b6 In order to receive Git push or Helm chart upload events, you'll have to expose the webhook receiver endpoint outside of your Kubernetes cluster on a public address. The notification controller handles webhook requests on port 9292 . This port can be used to create a Kubernetes LoadBalancer Service or Ingress. Create a LoadBalancer service: apiVersion : v1 kind : Service metadata : name : receiver namespace : gitops-system spec : type : LoadBalancer selector : app : notification-controller ports : - name : http port : 80 protocol : TCP targetPort : 9292 Wait for Kubernetes to assign a public address with: watch kubectl -n gitops-system get svc/receiver Define a Git repository \u00b6 Create a Git source pointing to a GitHub repository that you have control over: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : webapp namespace : gitops-system spec : interval : 60m url : https://github.com/<GH-ORG>/<GH-REPO> ref : branch : master Authentication SSH or token based authentication can be configured for private repositories. See the GitRepository CRD docs for more details. Define a Git repository receiver \u00b6 First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN Create a receiver for GitHub and specify the GitRepository object: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : webapp namespace : gitops-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note Besides GitHub, you can define receivers for GitLab , Bitbucket , Harbour and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details. The notification controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gitops-system get receiver/webapp NAME READY STATUS webapp True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b On GitHub, navigate to your repository and click on the \"Add webhook\" button under \"Settings/Webhooks\". Fill the form with: Payload URL : compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Secret : use the token string With the above settings, when you push a commit to the repository, the following happens: GitHub sends the Git push event to the receiver address Notification controller validates the authenticity of the payload using HMAC Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the GitRepository revision Kustomize controller is notified about the revision change Kustomize controller reconciles all the Kustomizations that reference the GitRepository object","title":"Setup Webhook Receivers"},{"location":"guides/webhook-receivers/#setup-webhook-receivers","text":"The GitOps toolkit controllers are by design pull-based . In order to notify the controllers about changes in Git or Helm repositories, you can setup webhooks and trigger a cluster reconciliation every time a source changes. Using webhook receivers, you can build push-based GitOps pipelines that react to external events.","title":"Setup Webhook Receivers"},{"location":"guides/webhook-receivers/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The notification controller can handle events coming from external systems (GitHub, GitLab, Bitbucket, Harbour, Jenkins, etc) and notify the GitOps toolkit controllers about source changes. The notification controller is part of the default toolkit installation.","title":"Prerequisites"},{"location":"guides/webhook-receivers/#expose-the-webhook-receiver","text":"In order to receive Git push or Helm chart upload events, you'll have to expose the webhook receiver endpoint outside of your Kubernetes cluster on a public address. The notification controller handles webhook requests on port 9292 . This port can be used to create a Kubernetes LoadBalancer Service or Ingress. Create a LoadBalancer service: apiVersion : v1 kind : Service metadata : name : receiver namespace : gitops-system spec : type : LoadBalancer selector : app : notification-controller ports : - name : http port : 80 protocol : TCP targetPort : 9292 Wait for Kubernetes to assign a public address with: watch kubectl -n gitops-system get svc/receiver","title":"Expose the webhook receiver"},{"location":"guides/webhook-receivers/#define-a-git-repository","text":"Create a Git source pointing to a GitHub repository that you have control over: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : webapp namespace : gitops-system spec : interval : 60m url : https://github.com/<GH-ORG>/<GH-REPO> ref : branch : master Authentication SSH or token based authentication can be configured for private repositories. See the GitRepository CRD docs for more details.","title":"Define a Git repository"},{"location":"guides/webhook-receivers/#define-a-git-repository-receiver","text":"First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN Create a receiver for GitHub and specify the GitRepository object: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : webapp namespace : gitops-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note Besides GitHub, you can define receivers for GitLab , Bitbucket , Harbour and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details. The notification controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gitops-system get receiver/webapp NAME READY STATUS webapp True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b On GitHub, navigate to your repository and click on the \"Add webhook\" button under \"Settings/Webhooks\". Fill the form with: Payload URL : compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Secret : use the token string With the above settings, when you push a commit to the repository, the following happens: GitHub sends the Git push event to the receiver address Notification controller validates the authenticity of the payload using HMAC Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the GitRepository revision Kustomize controller is notified about the revision change Kustomize controller reconciles all the Kustomizations that reference the GitRepository object","title":"Define a Git repository receiver"},{"location":"internal/release/","text":"Release \u00b6 To release a new version the following steps should be followed: Create a <next semver> tag form master and push it to remote. Confirm CI builds and releases the newly tagged version.","title":"Release"},{"location":"internal/release/#release","text":"To release a new version the following steps should be followed: Create a <next semver> tag form master and push it to remote. Confirm CI builds and releases the newly tagged version.","title":"Release"},{"location":"proposals/go-git-providers/","text":"go-git-providers \u00b6 Abstract \u00b6 This proposal aims to create a library with the import path github.com/fluxcd/go-git-providers ' (import name: gitprovider ), which provides an abstraction layer for talking to Git providers like GitHub, GitLab and Bitbucket. This would become a new repository, specifically targeted at being a general-purpose Git provider client for multiple providers and domains. Goals \u00b6 Support multiple Git provider backends (e.g. GitHub, GitLab, Bitbucket, etc.) using the same interface Support talking to multiple domains at once, including custom domains (e.g. talking to \"gitlab.com\" and \"version.aalto.fi\" from the same client) Support both no authentication (for public repos), basic auth, and OAuth2 for authentication Manipulating the following resources: Organizations : GET , LIST (both all accessible top-level orgs and sub-orgs) For a given Organization : Teams : GET and LIST Repositories : GET , LIST and POST Team Access : LIST , POST and DELETE Credentials : LIST , POST and DELETE Support sub-organizations (or \"sub-groups\" in GitLab) if possible Support reconciling an object for idempotent operations Pagination is automatically handled for LIST requests Transparently can manage teams (collections of users, sub-groups in Gitlab) with varying access to repos Follow library best practices in order to be easy to vendor (e.g. use major vX versioning & go.mod) Non-goals \u00b6 Support for features not mentioned above Design decisions \u00b6 A context.Context should be passed to every request as the first argument There should be two interfaces per resource, if applicable: one collection-specific interface, with a plural name (e.g. OrganizationsClient ), that has methods like Get() and List() one instance-specific interface, with a singular name (e.g. OrganizationClient ), that operates on that instance, e.g. allowing access to child resources, e.g. Teams() Every Create() signature shall have a {Resource}CreateOptions struct as the last argument. Delete() and similar methods may use the same pattern if needed All *Options structs shall be passed by value (i.e. non-nillable) and contain only nillable, optional fields All optional fields in the type structs shall be nillable It should be possible to create a fake API client for testing, implementing the same interfaces All type structs shall have a Validate() method, and optionally a Default() one All type structs shall expose their internal representation (from the underlying library) through the InternalGetter interface with a method GetInternal() interface{} Typed errors shall be returned, wrapped using Go 1.14's new features Go-style enums are used when there are only a few supported values for a field Every field is documented using Godoc comment, including +required or +optional to clearly signify its importance Support serializing the types to JSON (if needed for e.g. debugging) by adding tags Implementation \u00b6 Provider package \u00b6 The provider package, e.g. at github.com/fluxcd/go-git-providers/github , will have constructor methods so a client can be created, e.g. as follows: // Create a client for github.com without any authentication c := github . NewClient () // Create a client for an enterprise GitHub account, without any authentication c = github . NewClient ( github . WithBaseURL ( \"enterprise.github.com\" )) // Create a client for github.com using a personal oauth2 token c = github . NewClient ( github . WithOAuth2 ( \"<token-here>\" )) Client \u00b6 The definition of a Client is as follows: // Client is an interface that allows talking to a Git provider type Client interface { // The Client allows accessing all known resources ResourceClient // SupportedDomain returns the supported domain // This field is set at client creation time, and can't be changed SupportedDomain () string // ProviderID returns the provider ID (e.g. \"github\", \"gitlab\") for this client // This field is set at client creation time, and can't be changed ProviderID () ProviderID // Raw returns the Go client used under the hood for accessing the Git provider Raw () interface {} } As one can see, the Client is scoped for a single backing domain. ProviderID is a typed string, and every implementation package defines their own constant, e.g. const ProviderName = gitprovider.ProviderID(\"github\") . The ResourceClient actually allows talking to resources of the API, both for single objects, and collections: // ResourceClient allows access to resource-specific clients type ResourceClient interface { // Organization gets the OrganizationClient for the specific top-level organization // ErrNotTopLevelOrganization will be returned if the organization is not top-level when using Organization ( o OrganizationRef ) OrganizationClient // Organizations returns the OrganizationsClient handling sets of organizations Organizations () OrganizationsClient // Repository gets the RepositoryClient for the specified RepositoryRef Repository ( r RepositoryRef ) RepositoryClient // Repositories returns the RepositoriesClient handling sets of organizations Repositories () RepositoriesClient } In order to reference organizations and repositories, there are the OrganizationRef and RepositoryRef interfaces: // OrganizationRef references an organization in a Git provider type OrganizationRef interface { // String returns the HTTPS URL fmt . Stringer // GetDomain returns the URL-domain for the Git provider backend, e.g. gitlab.com or version.aalto.fi GetDomain () string // GetOrganization returns the top-level organization, i.e. \"weaveworks\" or \"kubernetes-sigs\" GetOrganization () string // GetSubOrganizations returns the names of sub-organizations (or sub-groups), // e.g. [\"engineering\", \"frontend\"] would be returned for gitlab.com/weaveworks/engineering/frontend GetSubOrganizations () [] string } // RepositoryRef references a repository hosted by a Git provider type RepositoryRef interface { // RepositoryRef requires an OrganizationRef to fully-qualify a repo reference OrganizationRef // GetRepository returns the name of the repository GetRepository () string } Along with these, there is OrganizationInfo and RepositoryInfo which implement the above mentioned interfaces in a straightforward way. If you want to create an OrganizationRef or RepositoryRef , you can either use NewOrganizationInfo() or NewRepositoryInfo() , filling in all parts of the reference, or use the ParseRepositoryURL(r string) (RepositoryRef, error) or ParseOrganizationURL(o string) (OrganizationRef, error) methods. As mentioned above, only one target domain is supported by the Client . This means e.g. that if the Client is configured for GitHub, and you feed it a GitLab URL to parse, ErrDomainUnsupported will be returned. This brings us to a higher-level client abstraction, MultiClient . MultiClient \u00b6 In order to automatically support multiple domains and providers using the same interface, MultiClient is introduced. The user would use the MultiClient as follows: // Create a client to github.com without authentication gh := github . NewClient () // Create a client to gitlab.com, authenticating with basic auth gl := gitlab . NewClient ( gitlab . WithBasicAuth ( \"<username>\" , \"<password\" )) // Create a client to the GitLab instance at version.aalto.fi, with a given OAuth2 token aalto := gitlab . NewClient ( gitlab . WithBaseURL ( \"version.aalto.fi\" ), gitlab . WithOAuth2Token ( \"<your-token>\" )) // Create a MultiClient which supports talking to any of these backends client := gitprovider . NewMultiClient ( gh , gl , aalto ) The interface definition of MultiClient is similar to that one of Client , both embedding ResourceClient , but it also allows access to domain-specific underlying Client 's: // MultiClient allows talking to multiple Git providers at once type MultiClient interface { // The MultiClient allows accessing all known resources, automatically choosing the right underlying // Client based on the resource's domain ResourceClient // SupportedDomains returns a list of known domains SupportedDomains () [] string // ClientForDomain returns the Client used for a specific domain ClientForDomain ( domain string ) ( Client , bool ) } OrganizationsClient \u00b6 The OrganizationsClient provides access to a set of organizations, as follows: // OrganizationsClient operates on organizations the user has access to type OrganizationsClient interface { // Get a specific organization the user has access to // This might also refer to a sub-organization // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , o OrganizationRef ) ( * Organization , error ) // List all top-level organizations the specific user has access to // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Organization , error ) // Children returns the immediate child-organizations for the specific OrganizationRef o. // The OrganizationRef may point to any sub-organization that exists // This is not supported in GitHub // Children should return all available organizations, using multiple paginated requests if needed Children ( ctx context . Context , o OrganizationRef ) ([] Organization , error ) // Possibly add Create/Update/Delete methods later } The Organization struct is fairly straightforward for now: // Organization represents an (top-level- or sub-) organization type Organization struct { // OrganizationInfo provides the required fields // (Domain, Organization and SubOrganizations) required for being an OrganizationRef OrganizationInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Name is the human-friendly name of this organization, e.g. \"Weaveworks\" or \"Kubernetes SIGs\" // +required Name string `json:\"name\"` // Description returns a description for the organization // No default value at POST-time // +optional Description * string `json:\"description\"` } The OrganizationInfo struct is a straightforward struct just implementing the OrganizationRef interface with basic fields & getters. InternalHolder is implementing the InternalGetter interface as follows, and is embedded into all main structs: // InternalGetter allows access to the underlying object type InternalGetter interface { // GetInternal returns the underlying struct that's used GetInternal () interface {} } // InternalHolder can be embedded into other structs to implement the InternalGetter interface type InternalHolder struct { // Internal contains the underlying object. // +optional Internal interface {} `json:\"-\"` } OrganizationClient \u00b6 OrganizationClient allows access to a specific organization's underlying resources as follows: // OrganizationClient operates on a given/specific organization type OrganizationClient interface { // Teams gives access to the TeamsClient for this specific organization Teams () OrganizationTeamsClient } Organization Teams \u00b6 Teams belonging to a certain organization can at this moment be fetched on an individual basis, or listed. // OrganizationTeamsClient handles teams organization-wide type OrganizationTeamsClient interface { // Get a team within the specific organization // teamName may include slashes, to point to e.g. \"sub-teams\" i.e. subgroups in Gitlab // teamName must not be an empty string // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , teamName string ) ( * Team , error ) // List all teams (recursively, in terms of subgroups) within the specific organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Team , error ) // Possibly add Create/Update/Delete methods later } The Team struct is defined as follows: // Team is a representation for a team of users inside of an organization type Team struct { // Team embeds OrganizationInfo which makes it automatically comply with OrganizationRef OrganizationInfo `json:\",inline\"` // Team embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Members points to a set of user names (logins) of the members of this team // +required Members [] string `json:\"members\"` } In GitLab, teams could be modelled as users in a sub-group. Those users can later be added as a single unit to access a given repository. RepositoriesClient \u00b6 RepositoriesClient provides access to a set of repositories for the user. // RepositoriesClient operates on repositories the user has access to type RepositoriesClient interface { // Get returns the repository at the given path // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , r RepositoryRef ) ( * Repository , error ) // List all repositories in the given organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context , o OrganizationRef ) ([] Repository , error ) // Create creates a repository at the given organization path, with the given URL-encoded name and options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , r * Repository , opts RepositoryCreateOptions ) ( * Repository , error ) // Reconcile makes sure r is the actual state in the backing Git provider. If r doesn't exist // under the hood, it is created. If r is already the actual state, this is a no-op. If r isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , r * Repository ) error } RepositoryCreateOptions has options like AutoInit *bool , LicenseTemplate *string and so forth to allow an one-time initialization step. The Repository struct is defined as follows: // Repository represents a Git repository provided by a Git provider type Repository struct { // RepositoryInfo provides the required fields // (Domain, Organization, SubOrganizations and RepositoryName) // required for being an RepositoryRef RepositoryInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Description returns a description for the repository // No default value at POST-time // +optional Description * string `json:\"description\"` // Visibility returns the desired visibility for the repository // Default value at POST-time: RepoVisibilityPrivate // +optional Visibility * RepoVisibility } // GetCloneURL gets the clone URL for the specified transport type func ( r * Repository ) GetCloneURL ( transport TransportType ) string { return GetCloneURL ( r , transport ) } As can be seen, there is also a GetCloneURL function for the repository which allows resolving the URL from which to clone the repo, for a given transport method ( ssh and https are supported TransportType s) RepositoryClient \u00b6 RepositoryClient allows access to a given repository's underlying resources, like follows: // RepositoryClient operates on a given/specific repository type RepositoryClient interface { // TeamAccess gives access to what teams have access to this specific repository TeamAccess () RepositoryTeamAccessClient // Credentials gives access to manipulating credentials for accessing this specific repository Credentials () RepositoryCredentialsClient } Repository Teams \u00b6 RepositoryTeamAccessClient allows adding & removing teams from the list of authorized persons to access a repository. // RepositoryTeamAccessClient operates on the teams list for a specific repository type RepositoryTeamAccessClient interface { // Create adds a given team to the repo's team access control list // ErrAlreadyExists will be returned if the resource already exists // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Create ( ctx context . Context , ta * TeamAccess , opts RepositoryAddTeamOptions ) error // Lists the team access control list for this repo List ( ctx context . Context ) ([] TeamAccess , error ) // Reconcile makes sure ta is the actual state in the backing Git provider. If ta doesn't exist // under the hood, it is created. If ta is already the actual state, this is a no-op. If ta isn't // the actual state, the resource will either be updated or deleted/recreated. // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Reconcile ( ctx context . Context , ta * TeamAccess ) error // Delete removes the given team from the repo's team access control list // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , teamName string ) error } The TeamAccess struct looks as follows: // TeamAccess describes a binding between a repository and a team type TeamAccess struct { // TeamAccess embeds RepositoryInfo which makes it automatically comply with RepositoryRef // +optional RepositoryInfo `json:\",inline\"` // TeamAccess embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Permission describes the permission level for which the team is allowed to operate // Default: read // Available options: See the TeamRepositoryPermission enum // +optional Permission * TeamRepositoryPermission } Repository Credentials \u00b6 RepositoryCredentialsClient allows adding & removing credentials (e.g. deploy keys) from accessing a specific repository. // RepositoryCredentialsClient operates on the access credential list for a specific repository type RepositoryCredentialsClient interface { // Create a credential with the given human-readable name, the given bytes and optional options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , c RepositoryCredential , opts CredentialCreateOptions ) error // Lists all credentials for the given credential type List ( ctx context . Context , t RepositoryCredentialType ) ([] RepositoryCredential , error ) // Reconcile makes sure c is the actual state in the backing Git provider. If c doesn't exist // under the hood, it is created. If c is already the actual state, this is a no-op. If c isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , c RepositoryCredential ) error // Deletes a credential from the repo. name corresponds to GetName() of the credential // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , t RepositoryCredentialType , name string ) error } In order to support multiple different types of credentials, RepositoryCredential is an interface: // RepositoryCredential is a credential that allows access (either read-only or read-write) to the repo type RepositoryCredential interface { // GetType returns the type of the credential GetType () RepositoryCredentialType // GetName returns a name (or title/description) of the credential GetName () string // GetData returns the key that will be authorized to access the repo, this can e.g. be a SSH public key GetData () [] byte // IsReadOnly returns whether this credential is authorized to write to the repository or not IsReadOnly () bool } The default implementation of RepositoryCredential is DeployKey : // DeployKey represents a short-lived credential (e.g. an SSH public key) used for accessing a repository type DeployKey struct { // DeployKey embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Title is the human-friendly interpretation of what the key is for (and does) // +required Title string `json:\"title\"` // Key specifies the public part of the deploy (e.g. SSH) key // +required Key [] byte `json:\"key\"` // ReadOnly specifies whether this DeployKey can write to the repository or not // Default value at POST-time: true // +optional ReadOnly * bool `json:\"readOnly\"` }","title":"go-git-providers"},{"location":"proposals/go-git-providers/#go-git-providers","text":"","title":"go-git-providers"},{"location":"proposals/go-git-providers/#abstract","text":"This proposal aims to create a library with the import path github.com/fluxcd/go-git-providers ' (import name: gitprovider ), which provides an abstraction layer for talking to Git providers like GitHub, GitLab and Bitbucket. This would become a new repository, specifically targeted at being a general-purpose Git provider client for multiple providers and domains.","title":"Abstract"},{"location":"proposals/go-git-providers/#goals","text":"Support multiple Git provider backends (e.g. GitHub, GitLab, Bitbucket, etc.) using the same interface Support talking to multiple domains at once, including custom domains (e.g. talking to \"gitlab.com\" and \"version.aalto.fi\" from the same client) Support both no authentication (for public repos), basic auth, and OAuth2 for authentication Manipulating the following resources: Organizations : GET , LIST (both all accessible top-level orgs and sub-orgs) For a given Organization : Teams : GET and LIST Repositories : GET , LIST and POST Team Access : LIST , POST and DELETE Credentials : LIST , POST and DELETE Support sub-organizations (or \"sub-groups\" in GitLab) if possible Support reconciling an object for idempotent operations Pagination is automatically handled for LIST requests Transparently can manage teams (collections of users, sub-groups in Gitlab) with varying access to repos Follow library best practices in order to be easy to vendor (e.g. use major vX versioning & go.mod)","title":"Goals"},{"location":"proposals/go-git-providers/#non-goals","text":"Support for features not mentioned above","title":"Non-goals"},{"location":"proposals/go-git-providers/#design-decisions","text":"A context.Context should be passed to every request as the first argument There should be two interfaces per resource, if applicable: one collection-specific interface, with a plural name (e.g. OrganizationsClient ), that has methods like Get() and List() one instance-specific interface, with a singular name (e.g. OrganizationClient ), that operates on that instance, e.g. allowing access to child resources, e.g. Teams() Every Create() signature shall have a {Resource}CreateOptions struct as the last argument. Delete() and similar methods may use the same pattern if needed All *Options structs shall be passed by value (i.e. non-nillable) and contain only nillable, optional fields All optional fields in the type structs shall be nillable It should be possible to create a fake API client for testing, implementing the same interfaces All type structs shall have a Validate() method, and optionally a Default() one All type structs shall expose their internal representation (from the underlying library) through the InternalGetter interface with a method GetInternal() interface{} Typed errors shall be returned, wrapped using Go 1.14's new features Go-style enums are used when there are only a few supported values for a field Every field is documented using Godoc comment, including +required or +optional to clearly signify its importance Support serializing the types to JSON (if needed for e.g. debugging) by adding tags","title":"Design decisions"},{"location":"proposals/go-git-providers/#implementation","text":"","title":"Implementation"},{"location":"proposals/go-git-providers/#provider-package","text":"The provider package, e.g. at github.com/fluxcd/go-git-providers/github , will have constructor methods so a client can be created, e.g. as follows: // Create a client for github.com without any authentication c := github . NewClient () // Create a client for an enterprise GitHub account, without any authentication c = github . NewClient ( github . WithBaseURL ( \"enterprise.github.com\" )) // Create a client for github.com using a personal oauth2 token c = github . NewClient ( github . WithOAuth2 ( \"<token-here>\" ))","title":"Provider package"},{"location":"proposals/go-git-providers/#client","text":"The definition of a Client is as follows: // Client is an interface that allows talking to a Git provider type Client interface { // The Client allows accessing all known resources ResourceClient // SupportedDomain returns the supported domain // This field is set at client creation time, and can't be changed SupportedDomain () string // ProviderID returns the provider ID (e.g. \"github\", \"gitlab\") for this client // This field is set at client creation time, and can't be changed ProviderID () ProviderID // Raw returns the Go client used under the hood for accessing the Git provider Raw () interface {} } As one can see, the Client is scoped for a single backing domain. ProviderID is a typed string, and every implementation package defines their own constant, e.g. const ProviderName = gitprovider.ProviderID(\"github\") . The ResourceClient actually allows talking to resources of the API, both for single objects, and collections: // ResourceClient allows access to resource-specific clients type ResourceClient interface { // Organization gets the OrganizationClient for the specific top-level organization // ErrNotTopLevelOrganization will be returned if the organization is not top-level when using Organization ( o OrganizationRef ) OrganizationClient // Organizations returns the OrganizationsClient handling sets of organizations Organizations () OrganizationsClient // Repository gets the RepositoryClient for the specified RepositoryRef Repository ( r RepositoryRef ) RepositoryClient // Repositories returns the RepositoriesClient handling sets of organizations Repositories () RepositoriesClient } In order to reference organizations and repositories, there are the OrganizationRef and RepositoryRef interfaces: // OrganizationRef references an organization in a Git provider type OrganizationRef interface { // String returns the HTTPS URL fmt . Stringer // GetDomain returns the URL-domain for the Git provider backend, e.g. gitlab.com or version.aalto.fi GetDomain () string // GetOrganization returns the top-level organization, i.e. \"weaveworks\" or \"kubernetes-sigs\" GetOrganization () string // GetSubOrganizations returns the names of sub-organizations (or sub-groups), // e.g. [\"engineering\", \"frontend\"] would be returned for gitlab.com/weaveworks/engineering/frontend GetSubOrganizations () [] string } // RepositoryRef references a repository hosted by a Git provider type RepositoryRef interface { // RepositoryRef requires an OrganizationRef to fully-qualify a repo reference OrganizationRef // GetRepository returns the name of the repository GetRepository () string } Along with these, there is OrganizationInfo and RepositoryInfo which implement the above mentioned interfaces in a straightforward way. If you want to create an OrganizationRef or RepositoryRef , you can either use NewOrganizationInfo() or NewRepositoryInfo() , filling in all parts of the reference, or use the ParseRepositoryURL(r string) (RepositoryRef, error) or ParseOrganizationURL(o string) (OrganizationRef, error) methods. As mentioned above, only one target domain is supported by the Client . This means e.g. that if the Client is configured for GitHub, and you feed it a GitLab URL to parse, ErrDomainUnsupported will be returned. This brings us to a higher-level client abstraction, MultiClient .","title":"Client"},{"location":"proposals/go-git-providers/#multiclient","text":"In order to automatically support multiple domains and providers using the same interface, MultiClient is introduced. The user would use the MultiClient as follows: // Create a client to github.com without authentication gh := github . NewClient () // Create a client to gitlab.com, authenticating with basic auth gl := gitlab . NewClient ( gitlab . WithBasicAuth ( \"<username>\" , \"<password\" )) // Create a client to the GitLab instance at version.aalto.fi, with a given OAuth2 token aalto := gitlab . NewClient ( gitlab . WithBaseURL ( \"version.aalto.fi\" ), gitlab . WithOAuth2Token ( \"<your-token>\" )) // Create a MultiClient which supports talking to any of these backends client := gitprovider . NewMultiClient ( gh , gl , aalto ) The interface definition of MultiClient is similar to that one of Client , both embedding ResourceClient , but it also allows access to domain-specific underlying Client 's: // MultiClient allows talking to multiple Git providers at once type MultiClient interface { // The MultiClient allows accessing all known resources, automatically choosing the right underlying // Client based on the resource's domain ResourceClient // SupportedDomains returns a list of known domains SupportedDomains () [] string // ClientForDomain returns the Client used for a specific domain ClientForDomain ( domain string ) ( Client , bool ) }","title":"MultiClient"},{"location":"proposals/go-git-providers/#organizationsclient","text":"The OrganizationsClient provides access to a set of organizations, as follows: // OrganizationsClient operates on organizations the user has access to type OrganizationsClient interface { // Get a specific organization the user has access to // This might also refer to a sub-organization // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , o OrganizationRef ) ( * Organization , error ) // List all top-level organizations the specific user has access to // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Organization , error ) // Children returns the immediate child-organizations for the specific OrganizationRef o. // The OrganizationRef may point to any sub-organization that exists // This is not supported in GitHub // Children should return all available organizations, using multiple paginated requests if needed Children ( ctx context . Context , o OrganizationRef ) ([] Organization , error ) // Possibly add Create/Update/Delete methods later } The Organization struct is fairly straightforward for now: // Organization represents an (top-level- or sub-) organization type Organization struct { // OrganizationInfo provides the required fields // (Domain, Organization and SubOrganizations) required for being an OrganizationRef OrganizationInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Name is the human-friendly name of this organization, e.g. \"Weaveworks\" or \"Kubernetes SIGs\" // +required Name string `json:\"name\"` // Description returns a description for the organization // No default value at POST-time // +optional Description * string `json:\"description\"` } The OrganizationInfo struct is a straightforward struct just implementing the OrganizationRef interface with basic fields & getters. InternalHolder is implementing the InternalGetter interface as follows, and is embedded into all main structs: // InternalGetter allows access to the underlying object type InternalGetter interface { // GetInternal returns the underlying struct that's used GetInternal () interface {} } // InternalHolder can be embedded into other structs to implement the InternalGetter interface type InternalHolder struct { // Internal contains the underlying object. // +optional Internal interface {} `json:\"-\"` }","title":"OrganizationsClient"},{"location":"proposals/go-git-providers/#organizationclient","text":"OrganizationClient allows access to a specific organization's underlying resources as follows: // OrganizationClient operates on a given/specific organization type OrganizationClient interface { // Teams gives access to the TeamsClient for this specific organization Teams () OrganizationTeamsClient }","title":"OrganizationClient"},{"location":"proposals/go-git-providers/#organization-teams","text":"Teams belonging to a certain organization can at this moment be fetched on an individual basis, or listed. // OrganizationTeamsClient handles teams organization-wide type OrganizationTeamsClient interface { // Get a team within the specific organization // teamName may include slashes, to point to e.g. \"sub-teams\" i.e. subgroups in Gitlab // teamName must not be an empty string // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , teamName string ) ( * Team , error ) // List all teams (recursively, in terms of subgroups) within the specific organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Team , error ) // Possibly add Create/Update/Delete methods later } The Team struct is defined as follows: // Team is a representation for a team of users inside of an organization type Team struct { // Team embeds OrganizationInfo which makes it automatically comply with OrganizationRef OrganizationInfo `json:\",inline\"` // Team embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Members points to a set of user names (logins) of the members of this team // +required Members [] string `json:\"members\"` } In GitLab, teams could be modelled as users in a sub-group. Those users can later be added as a single unit to access a given repository.","title":"Organization Teams"},{"location":"proposals/go-git-providers/#repositoriesclient","text":"RepositoriesClient provides access to a set of repositories for the user. // RepositoriesClient operates on repositories the user has access to type RepositoriesClient interface { // Get returns the repository at the given path // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , r RepositoryRef ) ( * Repository , error ) // List all repositories in the given organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context , o OrganizationRef ) ([] Repository , error ) // Create creates a repository at the given organization path, with the given URL-encoded name and options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , r * Repository , opts RepositoryCreateOptions ) ( * Repository , error ) // Reconcile makes sure r is the actual state in the backing Git provider. If r doesn't exist // under the hood, it is created. If r is already the actual state, this is a no-op. If r isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , r * Repository ) error } RepositoryCreateOptions has options like AutoInit *bool , LicenseTemplate *string and so forth to allow an one-time initialization step. The Repository struct is defined as follows: // Repository represents a Git repository provided by a Git provider type Repository struct { // RepositoryInfo provides the required fields // (Domain, Organization, SubOrganizations and RepositoryName) // required for being an RepositoryRef RepositoryInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Description returns a description for the repository // No default value at POST-time // +optional Description * string `json:\"description\"` // Visibility returns the desired visibility for the repository // Default value at POST-time: RepoVisibilityPrivate // +optional Visibility * RepoVisibility } // GetCloneURL gets the clone URL for the specified transport type func ( r * Repository ) GetCloneURL ( transport TransportType ) string { return GetCloneURL ( r , transport ) } As can be seen, there is also a GetCloneURL function for the repository which allows resolving the URL from which to clone the repo, for a given transport method ( ssh and https are supported TransportType s)","title":"RepositoriesClient"},{"location":"proposals/go-git-providers/#repositoryclient","text":"RepositoryClient allows access to a given repository's underlying resources, like follows: // RepositoryClient operates on a given/specific repository type RepositoryClient interface { // TeamAccess gives access to what teams have access to this specific repository TeamAccess () RepositoryTeamAccessClient // Credentials gives access to manipulating credentials for accessing this specific repository Credentials () RepositoryCredentialsClient }","title":"RepositoryClient"},{"location":"proposals/go-git-providers/#repository-teams","text":"RepositoryTeamAccessClient allows adding & removing teams from the list of authorized persons to access a repository. // RepositoryTeamAccessClient operates on the teams list for a specific repository type RepositoryTeamAccessClient interface { // Create adds a given team to the repo's team access control list // ErrAlreadyExists will be returned if the resource already exists // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Create ( ctx context . Context , ta * TeamAccess , opts RepositoryAddTeamOptions ) error // Lists the team access control list for this repo List ( ctx context . Context ) ([] TeamAccess , error ) // Reconcile makes sure ta is the actual state in the backing Git provider. If ta doesn't exist // under the hood, it is created. If ta is already the actual state, this is a no-op. If ta isn't // the actual state, the resource will either be updated or deleted/recreated. // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Reconcile ( ctx context . Context , ta * TeamAccess ) error // Delete removes the given team from the repo's team access control list // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , teamName string ) error } The TeamAccess struct looks as follows: // TeamAccess describes a binding between a repository and a team type TeamAccess struct { // TeamAccess embeds RepositoryInfo which makes it automatically comply with RepositoryRef // +optional RepositoryInfo `json:\",inline\"` // TeamAccess embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Permission describes the permission level for which the team is allowed to operate // Default: read // Available options: See the TeamRepositoryPermission enum // +optional Permission * TeamRepositoryPermission }","title":"Repository Teams"},{"location":"proposals/go-git-providers/#repository-credentials","text":"RepositoryCredentialsClient allows adding & removing credentials (e.g. deploy keys) from accessing a specific repository. // RepositoryCredentialsClient operates on the access credential list for a specific repository type RepositoryCredentialsClient interface { // Create a credential with the given human-readable name, the given bytes and optional options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , c RepositoryCredential , opts CredentialCreateOptions ) error // Lists all credentials for the given credential type List ( ctx context . Context , t RepositoryCredentialType ) ([] RepositoryCredential , error ) // Reconcile makes sure c is the actual state in the backing Git provider. If c doesn't exist // under the hood, it is created. If c is already the actual state, this is a no-op. If c isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , c RepositoryCredential ) error // Deletes a credential from the repo. name corresponds to GetName() of the credential // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , t RepositoryCredentialType , name string ) error } In order to support multiple different types of credentials, RepositoryCredential is an interface: // RepositoryCredential is a credential that allows access (either read-only or read-write) to the repo type RepositoryCredential interface { // GetType returns the type of the credential GetType () RepositoryCredentialType // GetName returns a name (or title/description) of the credential GetName () string // GetData returns the key that will be authorized to access the repo, this can e.g. be a SSH public key GetData () [] byte // IsReadOnly returns whether this credential is authorized to write to the repository or not IsReadOnly () bool } The default implementation of RepositoryCredential is DeployKey : // DeployKey represents a short-lived credential (e.g. an SSH public key) used for accessing a repository type DeployKey struct { // DeployKey embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Title is the human-friendly interpretation of what the key is for (and does) // +required Title string `json:\"title\"` // Key specifies the public part of the deploy (e.g. SSH) key // +required Key [] byte `json:\"key\"` // ReadOnly specifies whether this DeployKey can write to the repository or not // Default value at POST-time: true // +optional ReadOnly * bool `json:\"readOnly\"` }","title":"Repository Credentials"},{"location":"roadmap/","text":"Roadmap \u00b6 Work in Progress We will be building the roadmap together with the Flux community, our end-users and everyone who is interested in integrating with us. So a lot of this is still TBD - read this as our shopping list of ideas after some brainstorming as Flux maintainers. The road to Flux v2 \u00b6 Flux read-only feature parity \u00b6 80% This would be the first stepping stone: we want the GitOps Toolkit to be on-par with today's Flux in read-only mode and FluxCloud notifications. Goals Offer an in-place migration tool for those that are using Flux in read-only mode to synchronize plain manifests Offer a migration guide for those that are using Flux in read-only mode to synchronize Kustomize overlays Offer a dedicated component for forwarding events to external messaging platforms Non-Goals Migrate users that are using Flux to run custom scripts with flux.yaml Automate the migration of flux.yaml kustomize users Tasks Design the events API Implement events in source and kustomize controllers Make the kustomize-controller apply/gc events on-par with Flux v1 apply events Design the notifications and events filtering API Implement a notification controller for Slack, MS Teams, Discord, Rocket Implement Prometheus metrics in source and kustomize controllers Review the git source and kustomize APIs Implement the migration command in tk Create a migration guide for flux.yaml kustomize users Include support for SOPS Flux image update feature parity \u00b6 0% Goals Offer components that can replace Flux v1 image update feature Non-Goals Maintain backwards compatibility with Flux v1 annotations Tasks Design the image scanning and automation API Implement an image scanning controller Design the automation component Implement the image scan/patch/push workflow Integrate the new components in the toolkit assembler Create a migration guide from Flux annotations The road to Helm Operator v2 \u00b6 Helm v3 feature parity \u00b6 50% Goals Offer a migration guide for those that are using Helm Operator with Helm v3 and Helm repositories Non-Goals Migrate users that are using Helm v2 Stretch-Goals Migrate users that are using Helm charts from Git Tasks Implement a Helm controller for Helm v3 covering all the current release options Discuss and design Helm releases based on source API: Providing values from sources Conditional remediation on failed Helm actions Support running Helm test actions on an interval Review the Helm release, chart and repository APIs Implement events in Helm controller Implement Prometheus metrics in Helm controller Create a migration guide for Helm Operator users","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Work in Progress We will be building the roadmap together with the Flux community, our end-users and everyone who is interested in integrating with us. So a lot of this is still TBD - read this as our shopping list of ideas after some brainstorming as Flux maintainers.","title":"Roadmap"},{"location":"roadmap/#the-road-to-flux-v2","text":"","title":"The road to Flux v2"},{"location":"roadmap/#flux-read-only-feature-parity","text":"80% This would be the first stepping stone: we want the GitOps Toolkit to be on-par with today's Flux in read-only mode and FluxCloud notifications. Goals Offer an in-place migration tool for those that are using Flux in read-only mode to synchronize plain manifests Offer a migration guide for those that are using Flux in read-only mode to synchronize Kustomize overlays Offer a dedicated component for forwarding events to external messaging platforms Non-Goals Migrate users that are using Flux to run custom scripts with flux.yaml Automate the migration of flux.yaml kustomize users Tasks Design the events API Implement events in source and kustomize controllers Make the kustomize-controller apply/gc events on-par with Flux v1 apply events Design the notifications and events filtering API Implement a notification controller for Slack, MS Teams, Discord, Rocket Implement Prometheus metrics in source and kustomize controllers Review the git source and kustomize APIs Implement the migration command in tk Create a migration guide for flux.yaml kustomize users Include support for SOPS","title":"Flux read-only feature parity"},{"location":"roadmap/#flux-image-update-feature-parity","text":"0% Goals Offer components that can replace Flux v1 image update feature Non-Goals Maintain backwards compatibility with Flux v1 annotations Tasks Design the image scanning and automation API Implement an image scanning controller Design the automation component Implement the image scan/patch/push workflow Integrate the new components in the toolkit assembler Create a migration guide from Flux annotations","title":"Flux image update feature parity"},{"location":"roadmap/#the-road-to-helm-operator-v2","text":"","title":"The road to Helm Operator v2"},{"location":"roadmap/#helm-v3-feature-parity","text":"50% Goals Offer a migration guide for those that are using Helm Operator with Helm v3 and Helm repositories Non-Goals Migrate users that are using Helm v2 Stretch-Goals Migrate users that are using Helm charts from Git Tasks Implement a Helm controller for Helm v3 covering all the current release options Discuss and design Helm releases based on source API: Providing values from sources Conditional remediation on failed Helm actions Support running Helm test actions on an interval Review the Helm release, chart and repository APIs Implement events in Helm controller Implement Prometheus metrics in Helm controller Create a migration guide for Helm Operator users","title":"Helm v3 feature parity"}]}